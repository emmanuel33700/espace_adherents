import { DoCheck, IterableDiffer, IterableDiffers, NgZone, OnDestroy, OnInit } from '@angular/core';
import { Layer } from 'leaflet';
import { LeafletDirective } from '../core/leaflet.directive';
/**
 * Layers directive
 *
 * This directive is used to directly control map layers. As changes are made to the input array of
 * layers, the map is synched to the array. As layers are added or removed from the input array, they
 * are also added or removed from the map. The input array is treated as immutable. To detect changes,
 * you must change the array instance.
 *
 * Important Note: The input layers array is assumed to be immutable. This means you need to use an
 * immutable array implementation or create a new copy of your array when you make changes, otherwise
 * this directive won't detect the change. This is by design. It's for performance reasons. Change
 * detection of mutable arrays requires diffing the state of the array on every DoCheck cycle, which
 * is extremely expensive from a time complexity perspective.
 *
 */
import * as ɵngcc0 from '@angular/core';
export declare class LeafletLayersDirective implements DoCheck, OnDestroy, OnInit {
    private differs;
    private zone;
    layersValue: Layer[];
    layersDiffer: IterableDiffer<Layer>;
    layers: Layer[];
    private leafletDirective;
    constructor(leafletDirective: LeafletDirective, differs: IterableDiffers, zone: NgZone);
    ngDoCheck(): void;
    ngOnInit(): void;
    ngOnDestroy(): void;
    /**
     * Update the state of the layers.
     * We use an iterable differ to synchronize the map layers with the state of the bound layers array.
     * This is important because it allows us to react to changes to the contents of the array as well
     * as changes to the actual array instance.
     */
    private updateLayers();
    static ɵfac: ɵngcc0.ɵɵFactoryDef<LeafletLayersDirective, never>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<LeafletLayersDirective, "[leafletLayers]", never, { "layers": "leafletLayers"; }, {}, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGVhZmxldC1sYXllcnMuZGlyZWN0aXZlLmQudHMiLCJzb3VyY2VzIjpbImxlYWZsZXQtbGF5ZXJzLmRpcmVjdGl2ZS5kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0JBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWtCQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERvQ2hlY2ssIEl0ZXJhYmxlRGlmZmVyLCBJdGVyYWJsZURpZmZlcnMsIE5nWm9uZSwgT25EZXN0cm95LCBPbkluaXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IExheWVyIH0gZnJvbSAnbGVhZmxldCc7XG5pbXBvcnQgeyBMZWFmbGV0RGlyZWN0aXZlIH0gZnJvbSAnLi4vY29yZS9sZWFmbGV0LmRpcmVjdGl2ZSc7XG4vKipcbiAqIExheWVycyBkaXJlY3RpdmVcbiAqXG4gKiBUaGlzIGRpcmVjdGl2ZSBpcyB1c2VkIHRvIGRpcmVjdGx5IGNvbnRyb2wgbWFwIGxheWVycy4gQXMgY2hhbmdlcyBhcmUgbWFkZSB0byB0aGUgaW5wdXQgYXJyYXkgb2ZcbiAqIGxheWVycywgdGhlIG1hcCBpcyBzeW5jaGVkIHRvIHRoZSBhcnJheS4gQXMgbGF5ZXJzIGFyZSBhZGRlZCBvciByZW1vdmVkIGZyb20gdGhlIGlucHV0IGFycmF5LCB0aGV5XG4gKiBhcmUgYWxzbyBhZGRlZCBvciByZW1vdmVkIGZyb20gdGhlIG1hcC4gVGhlIGlucHV0IGFycmF5IGlzIHRyZWF0ZWQgYXMgaW1tdXRhYmxlLiBUbyBkZXRlY3QgY2hhbmdlcyxcbiAqIHlvdSBtdXN0IGNoYW5nZSB0aGUgYXJyYXkgaW5zdGFuY2UuXG4gKlxuICogSW1wb3J0YW50IE5vdGU6IFRoZSBpbnB1dCBsYXllcnMgYXJyYXkgaXMgYXNzdW1lZCB0byBiZSBpbW11dGFibGUuIFRoaXMgbWVhbnMgeW91IG5lZWQgdG8gdXNlIGFuXG4gKiBpbW11dGFibGUgYXJyYXkgaW1wbGVtZW50YXRpb24gb3IgY3JlYXRlIGEgbmV3IGNvcHkgb2YgeW91ciBhcnJheSB3aGVuIHlvdSBtYWtlIGNoYW5nZXMsIG90aGVyd2lzZVxuICogdGhpcyBkaXJlY3RpdmUgd29uJ3QgZGV0ZWN0IHRoZSBjaGFuZ2UuIFRoaXMgaXMgYnkgZGVzaWduLiBJdCdzIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLiBDaGFuZ2VcbiAqIGRldGVjdGlvbiBvZiBtdXRhYmxlIGFycmF5cyByZXF1aXJlcyBkaWZmaW5nIHRoZSBzdGF0ZSBvZiB0aGUgYXJyYXkgb24gZXZlcnkgRG9DaGVjayBjeWNsZSwgd2hpY2hcbiAqIGlzIGV4dHJlbWVseSBleHBlbnNpdmUgZnJvbSBhIHRpbWUgY29tcGxleGl0eSBwZXJzcGVjdGl2ZS5cbiAqXG4gKi9cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIExlYWZsZXRMYXllcnNEaXJlY3RpdmUgaW1wbGVtZW50cyBEb0NoZWNrLCBPbkRlc3Ryb3ksIE9uSW5pdCB7XG4gICAgcHJpdmF0ZSBkaWZmZXJzO1xuICAgIHByaXZhdGUgem9uZTtcbiAgICBsYXllcnNWYWx1ZTogTGF5ZXJbXTtcbiAgICBsYXllcnNEaWZmZXI6IEl0ZXJhYmxlRGlmZmVyPExheWVyPjtcbiAgICBsYXllcnM6IExheWVyW107XG4gICAgcHJpdmF0ZSBsZWFmbGV0RGlyZWN0aXZlO1xuICAgIGNvbnN0cnVjdG9yKGxlYWZsZXREaXJlY3RpdmU6IExlYWZsZXREaXJlY3RpdmUsIGRpZmZlcnM6IEl0ZXJhYmxlRGlmZmVycywgem9uZTogTmdab25lKTtcbiAgICBuZ0RvQ2hlY2soKTogdm9pZDtcbiAgICBuZ09uSW5pdCgpOiB2b2lkO1xuICAgIG5nT25EZXN0cm95KCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBzdGF0ZSBvZiB0aGUgbGF5ZXJzLlxuICAgICAqIFdlIHVzZSBhbiBpdGVyYWJsZSBkaWZmZXIgdG8gc3luY2hyb25pemUgdGhlIG1hcCBsYXllcnMgd2l0aCB0aGUgc3RhdGUgb2YgdGhlIGJvdW5kIGxheWVycyBhcnJheS5cbiAgICAgKiBUaGlzIGlzIGltcG9ydGFudCBiZWNhdXNlIGl0IGFsbG93cyB1cyB0byByZWFjdCB0byBjaGFuZ2VzIHRvIHRoZSBjb250ZW50cyBvZiB0aGUgYXJyYXkgYXMgd2VsbFxuICAgICAqIGFzIGNoYW5nZXMgdG8gdGhlIGFjdHVhbCBhcnJheSBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBwcml2YXRlIHVwZGF0ZUxheWVycygpO1xufVxuIl19