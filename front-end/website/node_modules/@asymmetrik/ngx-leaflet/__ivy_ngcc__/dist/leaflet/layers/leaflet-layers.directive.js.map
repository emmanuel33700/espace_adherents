{"version":3,"file":"leaflet-layers.directive.js","sources":["../../../src/leaflet/layers/leaflet-layers.directive.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,SAAS,EAAE,OAAO,EAAE,KAAK,EAAE,cAAc,EAAE,eAAe,EAAE,MAAM,EAAE,SAAS,EAAE,MAAM,EAAE,MAAM,eAAe,CAAC;AAEtH,OAAO,EAAE,KAAK,EAAC,MAAM,SAAS,CAAC;AAE/B,OAAO,EAAE,gBAAgB,EAAE,MAAM,2BAA2B,CAAC;AAC7D,OAAO,EAAE,uBAAuB,EAAE,MAAM,mCAAmC,CAAC;;;;;;;;;;;;;;;;;AAiB1E;IA4BD,gCAAY,gBAAkC,EAAU,OAAwB,EAAU,IAAY;QAA9C,YAAO,GAAP,OAAO,CAAiB;QAAU,SAAI,GAAJ,IAAI,CAAQ;QACrG,IAAI,CAAC,gBAAgB,GAAG,IAAI,uBAAuB,CAAC,gBAAgB,CAAC,CAAC;QACtE,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,MAAM,EAAS,CAAC;KAC1D;0BAhBG,0CAAM;aAMV;YACC,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC;SACxB;;;kBARU,CAAU;YACpB,IAAI,CAAC,WAAW,GAAG,CAAC,CAAC;;YAGrB,IAAI,CAAC,YAAY,EAAE,CAAC;;;;;IAcrB,0CAAS,GAAT;QACC,IAAI,CAAC,YAAY,EAAE,CAAC;KACpB;IAED,yCAAQ,GAAR;;QAGC,IAAI,CAAC,gBAAgB,CAAC,IAAI,EAAE,CAAC;;QAG7B,IAAI,CAAC,YAAY,EAAE,CAAC;KAEpB;IAED,4CAAW,GAAX;QACC,IAAI,CAAC,MAAM,GAAG,EAAE,CAAC;KACjB;IAED;;;;;OAKG;;;;;;;IACK,6CAAY;;;;;;IAApB;QAEC,IAAM,GAAG,GAAG,IAAI,CAAC,gBAAgB,CAAC,MAAM,EAAE,CAAC;QAE3C,EAAE,CAAC,CAAC,IAAI,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,CAAC,YAAY,CAAC,CAAC,CAAC;YAE9C,IAAM,SAAO,GAAG,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;YACzD,EAAE,CAAC,CAAC,IAAI,IAAI,SAAO,CAAC,CAAC,CAAC;gBAErB,IAAI,CAAC,IAAI,CAAC,iBAAiB,CAAC;oBAC3B,SAAO,CAAC,kBAAkB,CAAC,UAAC,CAAC;wBAC5B,GAAG,CAAC,WAAW,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;qBACxB,CAAC,CAAC;oBACH,SAAO,CAAC,gBAAgB,CAAC,UAAC,CAAC;wBAC1B,GAAG,CAAC,QAAQ,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;qBACrB,CAAC,CAAC;iBACH,CAAC,CAAC;aAEH;SAED;KAED,CACF,AA5EU;;mCAHT,SAAS,SAAC;QACV,QAAQ,EAAE,iBAAiB,nBApBnB,gBAAgB;gBAqBxB,AAzBmD,eAAe;gBAAE,MAAM;;;2BAoCzE,KAAK,SAAC,eAAe;;;;;;;;;;;;oBACX;iCArCZ;;SA0Ba,sBAAsB","sourcesContent":["import { Directive, DoCheck, Input, IterableDiffer, IterableDiffers, NgZone, OnDestroy, OnInit } from '@angular/core';\n\nimport { Layer} from 'leaflet';\n\nimport { LeafletDirective } from '../core/leaflet.directive';\nimport { LeafletDirectiveWrapper } from '../core/leaflet.directive.wrapper';\n\n\n/**\n * Layers directive\n *\n * This directive is used to directly control map layers. As changes are made to the input array of\n * layers, the map is synched to the array. As layers are added or removed from the input array, they\n * are also added or removed from the map. The input array is treated as immutable. To detect changes,\n * you must change the array instance.\n *\n * Important Note: The input layers array is assumed to be immutable. This means you need to use an\n * immutable array implementation or create a new copy of your array when you make changes, otherwise\n * this directive won't detect the change. This is by design. It's for performance reasons. Change\n * detection of mutable arrays requires diffing the state of the array on every DoCheck cycle, which\n * is extremely expensive from a time complexity perspective.\n *\n */\n@Directive({\n\tselector: '[leafletLayers]'\n})\nexport class LeafletLayersDirective\n\timplements DoCheck, OnDestroy, OnInit {\n\n\t// Array of configured layers\n\tlayersValue: Layer[];\n\n\t// Differ to do change detection on the array\n\tlayersDiffer: IterableDiffer<Layer>;\n\n\t// Set/get the layers\n\t@Input('leafletLayers')\n\tset layers(v: Layer[]) {\n\t\tthis.layersValue = v;\n\n\t\t// Now that we have a differ, do an immediate layer update\n\t\tthis.updateLayers();\n\t}\n\tget layers(): Layer[] {\n\t\treturn this.layersValue;\n\t}\n\n\t// Wrapper for the leaflet directive (manages the parent directive)\n\tprivate leafletDirective: LeafletDirectiveWrapper;\n\n\tconstructor(leafletDirective: LeafletDirective, private differs: IterableDiffers, private zone: NgZone) {\n\t\tthis.leafletDirective = new LeafletDirectiveWrapper(leafletDirective);\n\t\tthis.layersDiffer = this.differs.find([]).create<Layer>();\n\t}\n\n\tngDoCheck() {\n\t\tthis.updateLayers();\n\t}\n\n\tngOnInit() {\n\n\t\t// Init the map\n\t\tthis.leafletDirective.init();\n\n\t\t// Update layers once the map is ready\n\t\tthis.updateLayers();\n\n\t}\n\n\tngOnDestroy() {\n\t\tthis.layers = [];\n\t}\n\n\t/**\n\t * Update the state of the layers.\n\t * We use an iterable differ to synchronize the map layers with the state of the bound layers array.\n\t * This is important because it allows us to react to changes to the contents of the array as well\n\t * as changes to the actual array instance.\n\t */\n\tprivate updateLayers() {\n\n\t\tconst map = this.leafletDirective.getMap();\n\n\t\tif (null != map && null != this.layersDiffer) {\n\n\t\t\tconst changes = this.layersDiffer.diff(this.layersValue);\n\t\t\tif (null != changes) {\n\n\t\t\t\tthis.zone.runOutsideAngular(() => {\n\t\t\t\t\tchanges.forEachRemovedItem((c) => {\n\t\t\t\t\t\tmap.removeLayer(c.item);\n\t\t\t\t\t});\n\t\t\t\t\tchanges.forEachAddedItem((c) => {\n\t\t\t\t\t\tmap.addLayer(c.item);\n\t\t\t\t\t});\n\t\t\t\t});\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n"]}