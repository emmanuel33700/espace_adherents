import { CommonModule } from '@angular/common';
import { Directive, TemplateRef, ElementRef, Input, EventEmitter, Component, ViewEncapsulation, NgZone, HostBinding, Output, ViewChild, ContentChildren, HostListener, forwardRef, NgModule } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';

/**
 * The ToggleLabel directive allows you to customize the label for the "On" and "Off" states,
 * allowing for more robust and complex displays.
 * This directive must be used in conjunction with a ng-template.
 */
class NgToggleLabel {
    constructor(templateRef, elRef) {
        this.templateRef = templateRef;
        this.elRef = elRef;
    }
    get element() {
        return this.elRef;
    }
}
NgToggleLabel.decorators = [
    { type: Directive, args: [{ selector: 'ng-template[ngToggleLabel]' },] }
];
NgToggleLabel.ctorParameters = () => [
    { type: TemplateRef },
    { type: ElementRef }
];
NgToggleLabel.propDecorators = {
    forLabel: [{ type: Input }]
};

/**
 * The Toggle directive allows for standalone or checkbox-enabled switch toggling via a UI element.
 * The toggle is styled using Bootstrap v4+ classes.
 * Accessibility implemented according to
 * https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles/checkbox_role
 */
class NgToggle {
    constructor(ngZone, element) {
        this.ngZone = ngZone;
        this.element = element;
        /**
         * Display text when toggled in the "On" position
         */
        this.onText = 'On';
        /**
         * Display text when toggled in the "Off" position
         */
        this.offText = 'Off';
        /**
         * Bootstrap color scheme when toggled in the "On" position (i.e. "primary" translates to "btn-primary")
         */
        this.onColor = 'primary';
        /**
         * Bootstrap color scheme when toggled in the "Off" position (i.e. "primary" translates to "btn-primary")
         */
        this.offColor = 'secondary';
        /**
         * Button size to display the toggle
         */
        this.size = '';
        /**
         * Whether the toggle is disabled or not
         */
        this.disabled = false;
        /**
         * An event fired when the user causes a change.
         * The payload of the event is the currently selected value.
         */
        this.valueChange = new EventEmitter();
        this.btnClass = true;
        this.tabindex = 0;
        this.role = 'checkbox';
        this.width = 0;
        this.handleWidth = 0;
        this._animate = true;
        this._innerAnimate = true;
        this._innerState = false;
        this._innerWidth = 'auto';
        this._disableInitialAnimation = false;
        this._dragStart = null;
        this._dragEnd = null;
        this._initialized = false;
        this._hidden = false;
    }
    /**
     * Optional. Enable/Disable the initial transition animation. May prevent unwanted animation display.
     */
    set outerAnimate(value) {
        this._disableInitialAnimation = value;
    }
    set value(value) {
        this.setState(value);
    }
    get value() {
        return this._innerState;
    }
    ngAfterViewInit() {
        this.calculateWidth();
        this._initialized = true;
        this.ngZone.run(() => setTimeout(() => this._disableInitialAnimation = false));
    }
    ngAfterViewChecked() {
        const hidden = this.element.nativeElement.offsetParent === null;
        if ((!this._initialized || this.width === 0) && this._hidden !== hidden) {
            this._initialized = false;
            this.calculateWidth();
            this._initialized = true;
        }
        this._hidden = hidden;
    }
    ngAfterContentInit() {
        const onElement = this.labelElements.find((item) => item.forLabel.toLowerCase() === 'on');
        const offElement = this.labelElements.find((item) => item.forLabel.toLowerCase() === 'off');
        if (onElement) {
            this.onLabel = onElement;
        }
        if (offElement) {
            this.offLabel = offElement;
        }
        if (onElement || offElement) {
            this.calculateWidth(true);
        }
    }
    ngOnChanges(changes) {
        if ('onText' in changes || 'offText' in changes || 'size' in changes) {
            this._initialized = false;
            this.calculateWidth(this._initialized);
            this._initialized = true;
        }
    }
    get largeButton() {
        return this.size === 'lg';
    }
    get smallButton() {
        return this.size === 'sm';
    }
    get handleDark() {
        return (this.value && this.onColor === 'light') || (!this.value && this.offColor === 'light');
    }
    get indeterminate() {
        return this._innerState === null || typeof this._innerState === 'undefined';
    }
    get toggledOn() {
        return this.innerState === true;
    }
    get toggledOff() {
        return this.innerState === false;
    }
    get innerState() {
        return this._innerState;
    }
    get ariaCheckedValue() {
        if (this.indeterminate) {
            return 'mixed';
        }
        return this.value ? 'true' : 'false';
    }
    get animate() {
        return this._animate && (!this._disableInitialAnimation || this._initialized && !this._disableInitialAnimation);
    }
    get marginLeft() {
        let margin = 0;
        if (!this._initialized) {
        }
        else if (this.indeterminate || this._innerState === null || typeof this._innerState === 'undefined') {
            margin = -(this.width / 2);
        }
        else if (this._dragEnd) {
            margin = this._dragEnd;
        }
        else if (!this._innerState) {
            margin = -this.width;
        }
        return margin + 'px';
    }
    handleResize() {
        this._initialized = false;
        this.calculateWidth(true);
        this._initialized = true;
    }
    handleClick() {
        if (!this.disabled && !this._dragEnd) {
            this.setState(!this._innerState);
        }
        else if (this._dragEnd) {
            this._dragEnd = null;
        }
    }
    onTouchStart(event) {
        this.onDragStart(event);
    }
    onMouseDown(event) {
        this.onDragStart(event);
    }
    onTouchMove(event) {
        this.onDragMove(event);
    }
    onMouseMove(event) {
        this.onDragMove(event);
    }
    onTouchEnd(event) {
        this.onDragEnd(event, true);
    }
    onMouseUp(event) {
        this.onDragEnd(event);
    }
    onMouseLeave(event) {
        this.onDragEnd(event, true);
    }
    onKeyDown(event) {
        if (!event.key || this.disabled) {
            return;
        }
        switch (event.key) {
            case 'Left':
            case 'ArrowLeft':
                event.preventDefault();
                event.stopImmediatePropagation();
                this.setState(false);
                break;
            case 'Right':
            case 'ArrowRight':
                event.preventDefault();
                event.stopImmediatePropagation();
                this.setState(true);
                break;
            case 'Spacebar':
            case ' ':
                event.preventDefault();
                event.stopImmediatePropagation();
                this.setState(!this.value);
        }
    }
    onDragStart(event) {
        if (event.target === this.handle$) {
            if (this._dragStart || this.disabled) {
                return;
            }
            event.preventDefault();
            event.stopPropagation();
            this._dragStart = (event.pageX || event.touches[0].pageX) - parseInt(this.container$.style.marginLeft, 10);
            if (this._animate) {
                this._animate = !this._animate;
            }
        }
    }
    onDragMove(event) {
        if (this._dragStart) {
            event.preventDefault();
            let difference = (event.pageX || event.touches[0].pageX) - this._dragStart;
            if (difference < -(Number(this.width)) || difference > 0) {
                return;
            }
            this._dragEnd = difference;
        }
    }
    onDragEnd(event, clearDragEnd = false) {
        if (this._dragStart) {
            event.preventDefault();
            event.stopPropagation();
            if (this._dragEnd) {
                this.setState(this._dragEnd > -(Number(this.width) / 2));
            }
            this._dragStart = null;
            if (clearDragEnd) {
                this._dragEnd = null;
            }
            if (this._innerAnimate && !this._animate) {
                this._animate = true;
            }
        }
    }
    calculateWidth(disableAnimation = false) {
        if (disableAnimation && this._innerAnimate) {
            this._animate = false;
        }
        const initialized = this._initialized;
        if (!initialized) {
            this.container$.style.width = 'auto';
            this.element$.style.width = 'auto';
        }
        this.on$.style.width = 'auto';
        this.off$.style.width = 'auto';
        setTimeout(() => {
            let width = this._innerWidth;
            if (this._innerWidth === 'auto') {
                width = Math.max(this.on$.offsetWidth, this.off$.offsetWidth);
            }
            this.handleWidth = this.handle$.offsetWidth;
            this.width = Number(width);
            if (!initialized) {
                this.container$.style.width = ((this.width * 2) + this.handleWidth) + 'px';
                this.element$.style.width = (this.width + this.handleWidth) + 'px';
            }
            this.ngZone.run(() => {
                this.on$.style.width = this.width + 'px';
                this.off$.style.width = this.width + 'px';
                setTimeout(() => {
                    if (disableAnimation && this._innerAnimate) {
                        this._animate = true;
                    }
                });
            });
        });
    }
    setState(value) {
        if (value !== this._innerState) {
            this._innerState = value;
            this.valueChange.emit(this._innerState);
        }
    }
    get element$() {
        return this.element.nativeElement;
    }
    get on$() {
        return this.onElement.nativeElement;
    }
    get off$() {
        return this.offElement.nativeElement;
    }
    get handle$() {
        return this.handleElement.nativeElement;
    }
    get container$() {
        return this.containerElement.nativeElement;
    }
}
NgToggle.decorators = [
    { type: Component, args: [{
                selector: 'ng-toggle',
                template: `
    <span #container class="ng-toggle-container" [style.marginLeft]="marginLeft">
      <span #on class="ng-toggle-on btn btn-{{onColor}}" [class.btn-lg]="largeButton"
            [class.btn-sm]="smallButton" [class.disabled]="disabled">
          <ng-template [ngTemplateOutlet]="onLabel?.templateRef"></ng-template>
          <ng-container *ngIf="!onLabel">{{onText}}</ng-container>
      </span>
      <span #handle class="ng-toggle-handle btn" [class.btn-lg]="largeButton"
            [class.btn-sm]="smallButton" [class.disabled]="disabled"
            [class.btn-light]="!handleDark" [class.btn-dark]="handleDark">&nbsp;</span>
      <span #off class="ng-toggle-off btn btn-{{offColor}}" [class.btn-lg]="largeButton"
            [class.btn-sm]="smallButton" [class.disabled]="disabled">
        <ng-template [ngTemplateOutlet]="offLabel?.templateRef"></ng-template>
        <ng-container *ngIf="!offLabel">{{offText}}</ng-container>
      </span>
    </span>
    <ng-content></ng-content>
    `,
                preserveWhitespaces: false,
                encapsulation: ViewEncapsulation.None,
                styles: ["ng-toggle{-moz-user-select:none;-ms-user-select:none;-webkit-user-select:none;box-sizing:content-box;cursor:pointer;direction:ltr;display:inline-block;overflow:hidden;padding:0!important;position:relative;text-align:left;transition:border-color .15s ease-in-out,box-shadow .15s ease-in-out;user-select:none;vertical-align:middle;z-index:0}ng-toggle.disabled,ng-toggle.disabled .btn{cursor:default}ng-toggle input{height:1px;position:absolute;visibility:hidden;width:1px;z-index:-1}ng-toggle .ng-toggle-container,ng-toggle .ng-toggle-handle,ng-toggle .ng-toggle-off,ng-toggle .ng-toggle-on{display:-ms-flexbox!important;display:flex!important}ng-toggle .ng-toggle-container{-ms-flex-align:stretch!important;-webkit-transform:translateZ(0);align-items:stretch!important;border-radius:0;top:0;transform:translateZ(0)}ng-toggle.ng-toggle-animate .ng-toggle-container{transition:margin-left .5s}ng-toggle .ng-toggle-off,ng-toggle .ng-toggle-on{-ms-flex-align:center!important;align-items:center!important;border-radius:0;text-align:center;z-index:1}ng-toggle .ng-toggle-handle,ng-toggle .ng-toggle-off,ng-toggle .ng-toggle-on{-moz-user-select:none;-ms-user-select:none;-webkit-user-select:none;box-sizing:border-box;cursor:pointer;user-select:none}ng-toggle .ng-toggle-handle{-ms-flex-item-align:stretch!important;-ms-grid-row-align:stretch!important;align-self:stretch!important;margin-bottom:-1px;margin-top:-1px;padding-left:0;padding-right:0;text-align:center;width:1em;z-index:100}"]
            },] }
];
NgToggle.ctorParameters = () => [
    { type: NgZone },
    { type: ElementRef }
];
NgToggle.propDecorators = {
    onText: [{ type: Input }],
    offText: [{ type: Input }],
    onColor: [{ type: Input }],
    offColor: [{ type: Input }],
    size: [{ type: Input }],
    disabled: [{ type: Input }, { type: HostBinding, args: ['class.disabled',] }, { type: HostBinding, args: ['class.ng-toggle-disabled',] }],
    valueChange: [{ type: Output }],
    btnClass: [{ type: HostBinding, args: ['class.btn',] }],
    tabindex: [{ type: Input, args: ['tabindex',] }, { type: HostBinding, args: ['attr.tabindex',] }],
    role: [{ type: Input, args: ['role',] }, { type: HostBinding, args: ['attr.role',] }],
    containerElement: [{ type: ViewChild, args: ['container', { static: true },] }],
    onElement: [{ type: ViewChild, args: ['on', { static: true },] }],
    offElement: [{ type: ViewChild, args: ['off', { static: true },] }],
    handleElement: [{ type: ViewChild, args: ['handle', { static: true },] }],
    labelElements: [{ type: ContentChildren, args: [NgToggleLabel,] }],
    outerAnimate: [{ type: Input, args: ['disableInitialAnimation',] }],
    value: [{ type: Input }],
    largeButton: [{ type: HostBinding, args: ['class.btn-lg',] }, { type: HostBinding, args: ['class.ng-toggle-lg',] }],
    smallButton: [{ type: HostBinding, args: ['class.btn-sm',] }, { type: HostBinding, args: ['class.ng-toggle-sm',] }],
    indeterminate: [{ type: HostBinding, args: ['class.ng-toggle-indeterminate',] }],
    toggledOn: [{ type: HostBinding, args: ['class.ng-toggled-on',] }],
    toggledOff: [{ type: HostBinding, args: ['class.ng-toggled-off',] }],
    ariaCheckedValue: [{ type: HostBinding, args: ['attr.aria-checked',] }],
    animate: [{ type: HostBinding, args: ['class.ng-toggle-animate',] }],
    handleResize: [{ type: HostListener, args: ['window:resize',] }],
    handleClick: [{ type: HostListener, args: ['click',] }],
    onTouchStart: [{ type: HostListener, args: ['touchstart', ['$event'],] }],
    onMouseDown: [{ type: HostListener, args: ['mousedown', ['$event'],] }],
    onTouchMove: [{ type: HostListener, args: ['touchmove', ['$event'],] }],
    onMouseMove: [{ type: HostListener, args: ['mousemove', ['$event'],] }],
    onTouchEnd: [{ type: HostListener, args: ['touchend', ['$event'],] }],
    onMouseUp: [{ type: HostListener, args: ['mouseup', ['$event'],] }],
    onMouseLeave: [{ type: HostListener, args: ['mouseleave', ['$event'],] }],
    onKeyDown: [{ type: HostListener, args: ['keydown', ['$event'],] }]
};

class NgToggleAccessor {
    constructor(_host) {
        this._host = _host;
        this._subscription = this._host.valueChange.subscribe(value => this.onChange(value));
    }
    ngOnDestroy() {
        if (this._subscription) {
            this._subscription.unsubscribe();
            this._subscription = null;
        }
    }
    onChange(_) {
        if (this._onChange) {
            this._onChange(this._host.value);
        }
    }
    onTouched() {
        if (this._onTouched) {
            this._onTouched();
        }
    }
    registerOnChange(fn) {
        this._onChange = fn;
    }
    registerOnTouched(fn) {
        this._onTouched = fn;
    }
    setDisabledState(isDisabled) {
        this._host.disabled = isDisabled;
    }
    writeValue(obj) {
        if (typeof obj === 'boolean' || obj === null) {
            this._host.value = obj;
        }
    }
}
NgToggleAccessor.decorators = [
    { type: Directive, args: [{
                selector: 'ng-toggle',
                host: { '(change)': 'onChange($event)', '(touch)': 'onTouched()' },
                providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => NgToggleAccessor), multi: true }]
            },] }
];
NgToggleAccessor.ctorParameters = () => [
    { type: NgToggle }
];

const declarations = [
    NgToggle,
    NgToggleAccessor,
    NgToggleLabel,
];
class NgToggleModule {
}
NgToggleModule.decorators = [
    { type: NgModule, args: [{ imports: [CommonModule], exports: declarations, declarations: declarations },] }
];

/**
 * Generated bundle index. Do not edit.
 */

export { NgToggle, NgToggleAccessor, NgToggleLabel, NgToggleModule };
//# sourceMappingURL=ng-toggle.js.map
