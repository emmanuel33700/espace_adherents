import { CommonModule } from '@angular/common';
import { Directive, TemplateRef, ElementRef, Input, EventEmitter, Component, ViewEncapsulation, NgZone, HostBinding, Output, ViewChild, ContentChildren, HostListener, forwardRef, NgModule } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';

/**
 * The ToggleLabel directive allows you to customize the label for the "On" and "Off" states,
 * allowing for more robust and complex displays.
 * This directive must be used in conjunction with a ng-template.
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';

const _c0 = ["container"];
const _c1 = ["on"];
const _c2 = ["off"];
const _c3 = ["handle"];
function NgToggle_ng_template_4_Template(rf, ctx) { }
function NgToggle_ng_container_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r3.onText);
} }
function NgToggle_ng_template_11_Template(rf, ctx) { }
function NgToggle_ng_container_12_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r7 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r7.offText);
} }
const _c4 = ["*"];
class NgToggleLabel {
    constructor(templateRef, elRef) {
        this.templateRef = templateRef;
        this.elRef = elRef;
    }
    get element() {
        return this.elRef;
    }
}
NgToggleLabel.ɵfac = function NgToggleLabel_Factory(t) { return new (t || NgToggleLabel)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
NgToggleLabel.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NgToggleLabel, selectors: [["ng-template", "ngToggleLabel", ""]], inputs: { forLabel: "forLabel" } });
NgToggleLabel.ctorParameters = () => [
    { type: TemplateRef },
    { type: ElementRef }
];
NgToggleLabel.propDecorators = {
    forLabel: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgToggleLabel, [{
        type: Directive,
        args: [{ selector: 'ng-template[ngToggleLabel]' }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }, { type: ɵngcc0.ElementRef }]; }, { forLabel: [{
            type: Input
        }] }); })();

/**
 * The Toggle directive allows for standalone or checkbox-enabled switch toggling via a UI element.
 * The toggle is styled using Bootstrap v4+ classes.
 * Accessibility implemented according to
 * https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles/checkbox_role
 */
class NgToggle {
    constructor(ngZone, element) {
        this.ngZone = ngZone;
        this.element = element;
        /**
         * Display text when toggled in the "On" position
         */
        this.onText = 'On';
        /**
         * Display text when toggled in the "Off" position
         */
        this.offText = 'Off';
        /**
         * Bootstrap color scheme when toggled in the "On" position (i.e. "primary" translates to "btn-primary")
         */
        this.onColor = 'primary';
        /**
         * Bootstrap color scheme when toggled in the "Off" position (i.e. "primary" translates to "btn-primary")
         */
        this.offColor = 'secondary';
        /**
         * Button size to display the toggle
         */
        this.size = '';
        /**
         * Whether the toggle is disabled or not
         */
        this.disabled = false;
        /**
         * An event fired when the user causes a change.
         * The payload of the event is the currently selected value.
         */
        this.valueChange = new EventEmitter();
        this.btnClass = true;
        this.tabindex = 0;
        this.role = 'checkbox';
        this.width = 0;
        this.handleWidth = 0;
        this._animate = true;
        this._innerAnimate = true;
        this._innerState = false;
        this._innerWidth = 'auto';
        this._disableInitialAnimation = false;
        this._dragStart = null;
        this._dragEnd = null;
        this._initialized = false;
        this._hidden = false;
    }
    /**
     * Optional. Enable/Disable the initial transition animation. May prevent unwanted animation display.
     */
    set outerAnimate(value) {
        this._disableInitialAnimation = value;
    }
    set value(value) {
        this.setState(value);
    }
    get value() {
        return this._innerState;
    }
    ngAfterViewInit() {
        this.calculateWidth();
        this._initialized = true;
        this.ngZone.run(() => setTimeout(() => this._disableInitialAnimation = false));
    }
    ngAfterViewChecked() {
        const hidden = this.element.nativeElement.offsetParent === null;
        if ((!this._initialized || this.width === 0) && this._hidden !== hidden) {
            this._initialized = false;
            this.calculateWidth();
            this._initialized = true;
        }
        this._hidden = hidden;
    }
    ngAfterContentInit() {
        const onElement = this.labelElements.find((item) => item.forLabel.toLowerCase() === 'on');
        const offElement = this.labelElements.find((item) => item.forLabel.toLowerCase() === 'off');
        if (onElement) {
            this.onLabel = onElement;
        }
        if (offElement) {
            this.offLabel = offElement;
        }
        if (onElement || offElement) {
            this.calculateWidth(true);
        }
    }
    ngOnChanges(changes) {
        if ('onText' in changes || 'offText' in changes || 'size' in changes) {
            this._initialized = false;
            this.calculateWidth(this._initialized);
            this._initialized = true;
        }
    }
    get largeButton() {
        return this.size === 'lg';
    }
    get smallButton() {
        return this.size === 'sm';
    }
    get handleDark() {
        return (this.value && this.onColor === 'light') || (!this.value && this.offColor === 'light');
    }
    get indeterminate() {
        return this._innerState === null || typeof this._innerState === 'undefined';
    }
    get toggledOn() {
        return this.innerState === true;
    }
    get toggledOff() {
        return this.innerState === false;
    }
    get innerState() {
        return this._innerState;
    }
    get ariaCheckedValue() {
        if (this.indeterminate) {
            return 'mixed';
        }
        return this.value ? 'true' : 'false';
    }
    get animate() {
        return this._animate && (!this._disableInitialAnimation || this._initialized && !this._disableInitialAnimation);
    }
    get marginLeft() {
        let margin = 0;
        if (!this._initialized) {
        }
        else if (this.indeterminate || this._innerState === null || typeof this._innerState === 'undefined') {
            margin = -(this.width / 2);
        }
        else if (this._dragEnd) {
            margin = this._dragEnd;
        }
        else if (!this._innerState) {
            margin = -this.width;
        }
        return margin + 'px';
    }
    handleResize() {
        this._initialized = false;
        this.calculateWidth(true);
        this._initialized = true;
    }
    handleClick() {
        if (!this.disabled && !this._dragEnd) {
            this.setState(!this._innerState);
        }
        else if (this._dragEnd) {
            this._dragEnd = null;
        }
    }
    onTouchStart(event) {
        this.onDragStart(event);
    }
    onMouseDown(event) {
        this.onDragStart(event);
    }
    onTouchMove(event) {
        this.onDragMove(event);
    }
    onMouseMove(event) {
        this.onDragMove(event);
    }
    onTouchEnd(event) {
        this.onDragEnd(event, true);
    }
    onMouseUp(event) {
        this.onDragEnd(event);
    }
    onMouseLeave(event) {
        this.onDragEnd(event, true);
    }
    onKeyDown(event) {
        if (!event.key || this.disabled) {
            return;
        }
        switch (event.key) {
            case 'Left':
            case 'ArrowLeft':
                event.preventDefault();
                event.stopImmediatePropagation();
                this.setState(false);
                break;
            case 'Right':
            case 'ArrowRight':
                event.preventDefault();
                event.stopImmediatePropagation();
                this.setState(true);
                break;
            case 'Spacebar':
            case ' ':
                event.preventDefault();
                event.stopImmediatePropagation();
                this.setState(!this.value);
        }
    }
    onDragStart(event) {
        if (event.target === this.handle$) {
            if (this._dragStart || this.disabled) {
                return;
            }
            event.preventDefault();
            event.stopPropagation();
            this._dragStart = (event.pageX || event.touches[0].pageX) - parseInt(this.container$.style.marginLeft, 10);
            if (this._animate) {
                this._animate = !this._animate;
            }
        }
    }
    onDragMove(event) {
        if (this._dragStart) {
            event.preventDefault();
            let difference = (event.pageX || event.touches[0].pageX) - this._dragStart;
            if (difference < -(Number(this.width)) || difference > 0) {
                return;
            }
            this._dragEnd = difference;
        }
    }
    onDragEnd(event, clearDragEnd = false) {
        if (this._dragStart) {
            event.preventDefault();
            event.stopPropagation();
            if (this._dragEnd) {
                this.setState(this._dragEnd > -(Number(this.width) / 2));
            }
            this._dragStart = null;
            if (clearDragEnd) {
                this._dragEnd = null;
            }
            if (this._innerAnimate && !this._animate) {
                this._animate = true;
            }
        }
    }
    calculateWidth(disableAnimation = false) {
        if (disableAnimation && this._innerAnimate) {
            this._animate = false;
        }
        const initialized = this._initialized;
        if (!initialized) {
            this.container$.style.width = 'auto';
            this.element$.style.width = 'auto';
        }
        this.on$.style.width = 'auto';
        this.off$.style.width = 'auto';
        setTimeout(() => {
            let width = this._innerWidth;
            if (this._innerWidth === 'auto') {
                width = Math.max(this.on$.offsetWidth, this.off$.offsetWidth);
            }
            this.handleWidth = this.handle$.offsetWidth;
            this.width = Number(width);
            if (!initialized) {
                this.container$.style.width = ((this.width * 2) + this.handleWidth) + 'px';
                this.element$.style.width = (this.width + this.handleWidth) + 'px';
            }
            this.ngZone.run(() => {
                this.on$.style.width = this.width + 'px';
                this.off$.style.width = this.width + 'px';
                setTimeout(() => {
                    if (disableAnimation && this._innerAnimate) {
                        this._animate = true;
                    }
                });
            });
        });
    }
    setState(value) {
        if (value !== this._innerState) {
            this._innerState = value;
            this.valueChange.emit(this._innerState);
        }
    }
    get element$() {
        return this.element.nativeElement;
    }
    get on$() {
        return this.onElement.nativeElement;
    }
    get off$() {
        return this.offElement.nativeElement;
    }
    get handle$() {
        return this.handleElement.nativeElement;
    }
    get container$() {
        return this.containerElement.nativeElement;
    }
}
NgToggle.ɵfac = function NgToggle_Factory(t) { return new (t || NgToggle)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
NgToggle.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NgToggle, selectors: [["ng-toggle"]], contentQueries: function NgToggle_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgToggleLabel, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.labelElements = _t);
    } }, viewQuery: function NgToggle_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c0, true);
        ɵngcc0.ɵɵstaticViewQuery(_c1, true);
        ɵngcc0.ɵɵstaticViewQuery(_c2, true);
        ɵngcc0.ɵɵstaticViewQuery(_c3, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.containerElement = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.onElement = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.offElement = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.handleElement = _t.first);
    } }, hostVars: 25, hostBindings: function NgToggle_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("resize", function NgToggle_resize_HostBindingHandler() { return ctx.handleResize(); }, false, ɵngcc0.ɵɵresolveWindow)("click", function NgToggle_click_HostBindingHandler() { return ctx.handleClick(); })("touchstart", function NgToggle_touchstart_HostBindingHandler($event) { return ctx.onTouchStart($event); })("mousedown", function NgToggle_mousedown_HostBindingHandler($event) { return ctx.onMouseDown($event); })("touchmove", function NgToggle_touchmove_HostBindingHandler($event) { return ctx.onTouchMove($event); })("mousemove", function NgToggle_mousemove_HostBindingHandler($event) { return ctx.onMouseMove($event); })("touchend", function NgToggle_touchend_HostBindingHandler($event) { return ctx.onTouchEnd($event); })("mouseup", function NgToggle_mouseup_HostBindingHandler($event) { return ctx.onMouseUp($event); })("mouseleave", function NgToggle_mouseleave_HostBindingHandler($event) { return ctx.onMouseLeave($event); })("keydown", function NgToggle_keydown_HostBindingHandler($event) { return ctx.onKeyDown($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("tabindex", ctx.tabindex)("role", ctx.role)("aria-checked", ctx.ariaCheckedValue);
        ɵngcc0.ɵɵclassProp("disabled", ctx.disabled)("ng-toggle-disabled", ctx.disabled)("btn", ctx.btnClass)("btn-lg", ctx.largeButton)("ng-toggle-lg", ctx.largeButton)("btn-sm", ctx.smallButton)("ng-toggle-sm", ctx.smallButton)("ng-toggle-indeterminate", ctx.indeterminate)("ng-toggled-on", ctx.toggledOn)("ng-toggled-off", ctx.toggledOff)("ng-toggle-animate", ctx.animate);
    } }, inputs: { onText: "onText", offText: "offText", onColor: "onColor", offColor: "offColor", size: "size", disabled: "disabled", tabindex: "tabindex", role: "role", outerAnimate: ["disableInitialAnimation", "outerAnimate"], value: "value" }, outputs: { valueChange: "valueChange" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c4, decls: 14, vars: 34, consts: [[1, "ng-toggle-container"], ["container", ""], ["on", ""], [3, "ngTemplateOutlet"], [4, "ngIf"], [1, "ng-toggle-handle", "btn"], ["handle", ""], ["off", ""]], template: function NgToggle_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "span", 0, 1);
        ɵngcc0.ɵɵelementStart(2, "span", null, 2);
        ɵngcc0.ɵɵtemplate(4, NgToggle_ng_template_4_Template, 0, 0, "ng-template", 3);
        ɵngcc0.ɵɵtemplate(5, NgToggle_ng_container_5_Template, 2, 1, "ng-container", 4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(6, "span", 5, 6);
        ɵngcc0.ɵɵtext(8, "\u00A0");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(9, "span", null, 7);
        ɵngcc0.ɵɵtemplate(11, NgToggle_ng_template_11_Template, 0, 0, "ng-template", 3);
        ɵngcc0.ɵɵtemplate(12, NgToggle_ng_container_12_Template, 2, 1, "ng-container", 4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵprojection(13);
    } if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("margin-left", ctx.marginLeft);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵclassMapInterpolate1("ng-toggle-on btn btn-", ctx.onColor, "");
        ɵngcc0.ɵɵclassProp("btn-lg", ctx.largeButton)("btn-sm", ctx.smallButton)("disabled", ctx.disabled);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.onLabel == null ? null : ctx.onLabel.templateRef);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.onLabel);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassProp("btn-lg", ctx.largeButton)("btn-sm", ctx.smallButton)("disabled", ctx.disabled)("btn-light", !ctx.handleDark)("btn-dark", ctx.handleDark);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵclassMapInterpolate1("ng-toggle-off btn btn-", ctx.offColor, "");
        ɵngcc0.ɵɵclassProp("btn-lg", ctx.largeButton)("btn-sm", ctx.smallButton)("disabled", ctx.disabled);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.offLabel == null ? null : ctx.offLabel.templateRef);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.offLabel);
    } }, directives: [ɵngcc1.NgTemplateOutlet, ɵngcc1.NgIf], styles: ["ng-toggle{-moz-user-select:none;-ms-user-select:none;-webkit-user-select:none;box-sizing:content-box;cursor:pointer;direction:ltr;display:inline-block;overflow:hidden;padding:0!important;position:relative;text-align:left;transition:border-color .15s ease-in-out,box-shadow .15s ease-in-out;user-select:none;vertical-align:middle;z-index:0}ng-toggle.disabled,ng-toggle.disabled .btn{cursor:default}ng-toggle input{height:1px;position:absolute;visibility:hidden;width:1px;z-index:-1}ng-toggle .ng-toggle-container,ng-toggle .ng-toggle-handle,ng-toggle .ng-toggle-off,ng-toggle .ng-toggle-on{display:-ms-flexbox!important;display:flex!important}ng-toggle .ng-toggle-container{-ms-flex-align:stretch!important;-webkit-transform:translateZ(0);align-items:stretch!important;border-radius:0;top:0;transform:translateZ(0)}ng-toggle.ng-toggle-animate .ng-toggle-container{transition:margin-left .5s}ng-toggle .ng-toggle-off,ng-toggle .ng-toggle-on{-ms-flex-align:center!important;align-items:center!important;border-radius:0;text-align:center;z-index:1}ng-toggle .ng-toggle-handle,ng-toggle .ng-toggle-off,ng-toggle .ng-toggle-on{-moz-user-select:none;-ms-user-select:none;-webkit-user-select:none;box-sizing:border-box;cursor:pointer;user-select:none}ng-toggle .ng-toggle-handle{-ms-flex-item-align:stretch!important;-ms-grid-row-align:stretch!important;align-self:stretch!important;margin-bottom:-1px;margin-top:-1px;padding-left:0;padding-right:0;text-align:center;width:1em;z-index:100}"], encapsulation: 2 });
NgToggle.ctorParameters = () => [
    { type: NgZone },
    { type: ElementRef }
];
NgToggle.propDecorators = {
    onText: [{ type: Input }],
    offText: [{ type: Input }],
    onColor: [{ type: Input }],
    offColor: [{ type: Input }],
    size: [{ type: Input }],
    disabled: [{ type: Input }, { type: HostBinding, args: ['class.disabled',] }, { type: HostBinding, args: ['class.ng-toggle-disabled',] }],
    valueChange: [{ type: Output }],
    btnClass: [{ type: HostBinding, args: ['class.btn',] }],
    tabindex: [{ type: Input, args: ['tabindex',] }, { type: HostBinding, args: ['attr.tabindex',] }],
    role: [{ type: Input, args: ['role',] }, { type: HostBinding, args: ['attr.role',] }],
    containerElement: [{ type: ViewChild, args: ['container', { static: true },] }],
    onElement: [{ type: ViewChild, args: ['on', { static: true },] }],
    offElement: [{ type: ViewChild, args: ['off', { static: true },] }],
    handleElement: [{ type: ViewChild, args: ['handle', { static: true },] }],
    labelElements: [{ type: ContentChildren, args: [NgToggleLabel,] }],
    outerAnimate: [{ type: Input, args: ['disableInitialAnimation',] }],
    value: [{ type: Input }],
    largeButton: [{ type: HostBinding, args: ['class.btn-lg',] }, { type: HostBinding, args: ['class.ng-toggle-lg',] }],
    smallButton: [{ type: HostBinding, args: ['class.btn-sm',] }, { type: HostBinding, args: ['class.ng-toggle-sm',] }],
    indeterminate: [{ type: HostBinding, args: ['class.ng-toggle-indeterminate',] }],
    toggledOn: [{ type: HostBinding, args: ['class.ng-toggled-on',] }],
    toggledOff: [{ type: HostBinding, args: ['class.ng-toggled-off',] }],
    ariaCheckedValue: [{ type: HostBinding, args: ['attr.aria-checked',] }],
    animate: [{ type: HostBinding, args: ['class.ng-toggle-animate',] }],
    handleResize: [{ type: HostListener, args: ['window:resize',] }],
    handleClick: [{ type: HostListener, args: ['click',] }],
    onTouchStart: [{ type: HostListener, args: ['touchstart', ['$event'],] }],
    onMouseDown: [{ type: HostListener, args: ['mousedown', ['$event'],] }],
    onTouchMove: [{ type: HostListener, args: ['touchmove', ['$event'],] }],
    onMouseMove: [{ type: HostListener, args: ['mousemove', ['$event'],] }],
    onTouchEnd: [{ type: HostListener, args: ['touchend', ['$event'],] }],
    onMouseUp: [{ type: HostListener, args: ['mouseup', ['$event'],] }],
    onMouseLeave: [{ type: HostListener, args: ['mouseleave', ['$event'],] }],
    onKeyDown: [{ type: HostListener, args: ['keydown', ['$event'],] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgToggle, [{
        type: Component,
        args: [{
                selector: 'ng-toggle',
                template: `
    <span #container class="ng-toggle-container" [style.marginLeft]="marginLeft">
      <span #on class="ng-toggle-on btn btn-{{onColor}}" [class.btn-lg]="largeButton"
            [class.btn-sm]="smallButton" [class.disabled]="disabled">
          <ng-template [ngTemplateOutlet]="onLabel?.templateRef"></ng-template>
          <ng-container *ngIf="!onLabel">{{onText}}</ng-container>
      </span>
      <span #handle class="ng-toggle-handle btn" [class.btn-lg]="largeButton"
            [class.btn-sm]="smallButton" [class.disabled]="disabled"
            [class.btn-light]="!handleDark" [class.btn-dark]="handleDark">&nbsp;</span>
      <span #off class="ng-toggle-off btn btn-{{offColor}}" [class.btn-lg]="largeButton"
            [class.btn-sm]="smallButton" [class.disabled]="disabled">
        <ng-template [ngTemplateOutlet]="offLabel?.templateRef"></ng-template>
        <ng-container *ngIf="!offLabel">{{offText}}</ng-container>
      </span>
    </span>
    <ng-content></ng-content>
    `,
                preserveWhitespaces: false,
                encapsulation: ViewEncapsulation.None,
                styles: ["ng-toggle{-moz-user-select:none;-ms-user-select:none;-webkit-user-select:none;box-sizing:content-box;cursor:pointer;direction:ltr;display:inline-block;overflow:hidden;padding:0!important;position:relative;text-align:left;transition:border-color .15s ease-in-out,box-shadow .15s ease-in-out;user-select:none;vertical-align:middle;z-index:0}ng-toggle.disabled,ng-toggle.disabled .btn{cursor:default}ng-toggle input{height:1px;position:absolute;visibility:hidden;width:1px;z-index:-1}ng-toggle .ng-toggle-container,ng-toggle .ng-toggle-handle,ng-toggle .ng-toggle-off,ng-toggle .ng-toggle-on{display:-ms-flexbox!important;display:flex!important}ng-toggle .ng-toggle-container{-ms-flex-align:stretch!important;-webkit-transform:translateZ(0);align-items:stretch!important;border-radius:0;top:0;transform:translateZ(0)}ng-toggle.ng-toggle-animate .ng-toggle-container{transition:margin-left .5s}ng-toggle .ng-toggle-off,ng-toggle .ng-toggle-on{-ms-flex-align:center!important;align-items:center!important;border-radius:0;text-align:center;z-index:1}ng-toggle .ng-toggle-handle,ng-toggle .ng-toggle-off,ng-toggle .ng-toggle-on{-moz-user-select:none;-ms-user-select:none;-webkit-user-select:none;box-sizing:border-box;cursor:pointer;user-select:none}ng-toggle .ng-toggle-handle{-ms-flex-item-align:stretch!important;-ms-grid-row-align:stretch!important;align-self:stretch!important;margin-bottom:-1px;margin-top:-1px;padding-left:0;padding-right:0;text-align:center;width:1em;z-index:100}"]
            }]
    }], function () { return [{ type: ɵngcc0.NgZone }, { type: ɵngcc0.ElementRef }]; }, { onText: [{
            type: Input
        }], offText: [{
            type: Input
        }], onColor: [{
            type: Input
        }], offColor: [{
            type: Input
        }], size: [{
            type: Input
        }], disabled: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['class.disabled']
        }, {
            type: HostBinding,
            args: ['class.ng-toggle-disabled']
        }], valueChange: [{
            type: Output
        }], btnClass: [{
            type: HostBinding,
            args: ['class.btn']
        }], tabindex: [{
            type: Input,
            args: ['tabindex']
        }, {
            type: HostBinding,
            args: ['attr.tabindex']
        }], role: [{
            type: Input,
            args: ['role']
        }, {
            type: HostBinding,
            args: ['attr.role']
        }], outerAnimate: [{
            type: Input,
            args: ['disableInitialAnimation']
        }], value: [{
            type: Input
        }], largeButton: [{
            type: HostBinding,
            args: ['class.btn-lg']
        }, {
            type: HostBinding,
            args: ['class.ng-toggle-lg']
        }], smallButton: [{
            type: HostBinding,
            args: ['class.btn-sm']
        }, {
            type: HostBinding,
            args: ['class.ng-toggle-sm']
        }], indeterminate: [{
            type: HostBinding,
            args: ['class.ng-toggle-indeterminate']
        }], toggledOn: [{
            type: HostBinding,
            args: ['class.ng-toggled-on']
        }], toggledOff: [{
            type: HostBinding,
            args: ['class.ng-toggled-off']
        }], ariaCheckedValue: [{
            type: HostBinding,
            args: ['attr.aria-checked']
        }], animate: [{
            type: HostBinding,
            args: ['class.ng-toggle-animate']
        }], handleResize: [{
            type: HostListener,
            args: ['window:resize']
        }], handleClick: [{
            type: HostListener,
            args: ['click']
        }], onTouchStart: [{
            type: HostListener,
            args: ['touchstart', ['$event']]
        }], onMouseDown: [{
            type: HostListener,
            args: ['mousedown', ['$event']]
        }], onTouchMove: [{
            type: HostListener,
            args: ['touchmove', ['$event']]
        }], onMouseMove: [{
            type: HostListener,
            args: ['mousemove', ['$event']]
        }], onTouchEnd: [{
            type: HostListener,
            args: ['touchend', ['$event']]
        }], onMouseUp: [{
            type: HostListener,
            args: ['mouseup', ['$event']]
        }], onMouseLeave: [{
            type: HostListener,
            args: ['mouseleave', ['$event']]
        }], onKeyDown: [{
            type: HostListener,
            args: ['keydown', ['$event']]
        }], containerElement: [{
            type: ViewChild,
            args: ['container', { static: true }]
        }], onElement: [{
            type: ViewChild,
            args: ['on', { static: true }]
        }], offElement: [{
            type: ViewChild,
            args: ['off', { static: true }]
        }], handleElement: [{
            type: ViewChild,
            args: ['handle', { static: true }]
        }], labelElements: [{
            type: ContentChildren,
            args: [NgToggleLabel]
        }] }); })();

class NgToggleAccessor {
    constructor(_host) {
        this._host = _host;
        this._subscription = this._host.valueChange.subscribe(value => this.onChange(value));
    }
    ngOnDestroy() {
        if (this._subscription) {
            this._subscription.unsubscribe();
            this._subscription = null;
        }
    }
    onChange(_) {
        if (this._onChange) {
            this._onChange(this._host.value);
        }
    }
    onTouched() {
        if (this._onTouched) {
            this._onTouched();
        }
    }
    registerOnChange(fn) {
        this._onChange = fn;
    }
    registerOnTouched(fn) {
        this._onTouched = fn;
    }
    setDisabledState(isDisabled) {
        this._host.disabled = isDisabled;
    }
    writeValue(obj) {
        if (typeof obj === 'boolean' || obj === null) {
            this._host.value = obj;
        }
    }
}
NgToggleAccessor.ɵfac = function NgToggleAccessor_Factory(t) { return new (t || NgToggleAccessor)(ɵngcc0.ɵɵdirectiveInject(NgToggle)); };
NgToggleAccessor.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NgToggleAccessor, selectors: [["ng-toggle"]], hostBindings: function NgToggleAccessor_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("change", function NgToggleAccessor_change_HostBindingHandler($event) { return ctx.onChange($event); })("touch", function NgToggleAccessor_touch_HostBindingHandler() { return ctx.onTouched(); });
    } }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => NgToggleAccessor), multi: true }])] });
NgToggleAccessor.ctorParameters = () => [
    { type: NgToggle }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgToggleAccessor, [{
        type: Directive,
        args: [{
                selector: 'ng-toggle',
                host: { '(change)': 'onChange($event)', '(touch)': 'onTouched()' },
                providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => NgToggleAccessor), multi: true }]
            }]
    }], function () { return [{ type: NgToggle }]; }, null); })();

const declarations = [
    NgToggle,
    NgToggleAccessor,
    NgToggleLabel,
];
class NgToggleModule {
}
NgToggleModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NgToggleModule });
NgToggleModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NgToggleModule_Factory(t) { return new (t || NgToggleModule)(); }, imports: [[CommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NgToggleModule, { declarations: function () { return [NgToggle,
        NgToggleAccessor,
        NgToggleLabel]; }, imports: function () { return [CommonModule]; }, exports: function () { return [NgToggle,
        NgToggleAccessor,
        NgToggleLabel]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgToggleModule, [{
        type: NgModule,
        args: [{ imports: [CommonModule], exports: declarations, declarations: declarations }]
    }], null, null); })();

/**
 * Generated bundle index. Do not edit.
 */

export { NgToggle, NgToggleAccessor, NgToggleLabel, NgToggleModule };

//# sourceMappingURL=ng-toggle.js.map