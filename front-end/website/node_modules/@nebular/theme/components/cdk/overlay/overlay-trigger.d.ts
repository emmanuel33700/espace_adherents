import { ComponentRef } from '@angular/core';
import { Observable, Subject } from 'rxjs';
import * as ɵngcc0 from '@angular/core';
export declare type NbTriggerValues = 'noop' | 'click' | 'hover' | 'hint' | 'focus';
export declare enum NbTrigger {
    NOOP = "noop",
    CLICK = "click",
    HOVER = "hover",
    HINT = "hint",
    FOCUS = "focus"
}
/**
 * Provides entity with two event stream: show and hide.
 * Each stream provides different events depends on implementation.
 * We have three main trigger strategies: click, hint and hover.
 * */
export interface NbTriggerStrategy {
    show$: Observable<never | Event>;
    hide$: Observable<never | Event>;
    destroy(): any;
}
/**
 * TODO maybe we have to use renderer.listen instead of observableFromEvent?
 * Renderer provides capability use it in service worker, ssr and so on.
 * */
export declare abstract class NbTriggerStrategyBase implements NbTriggerStrategy {
    protected document: Document;
    protected host: HTMLElement;
    protected container: () => ComponentRef<any>;
    destroy(): void;
    protected destroyed$: Subject<unknown>;
    protected isNotOnHostOrContainer(event: Event): boolean;
    protected isOnHostOrContainer(event: Event): boolean;
    protected isOnHost({ target }: Event): boolean;
    protected isOnContainer({ target }: Event): boolean;
    abstract show$: Observable<Event>;
    abstract hide$: Observable<Event>;
    constructor(document: Document, host: HTMLElement, container: () => ComponentRef<any>);
}
/**
 * Creates show and hide event streams.
 * Fires toggle event when the click was performed on the host element.
 * Fires close event when the click was performed on the document but
 * not on the host or container.
 * */
export declare class NbClickTriggerStrategy extends NbTriggerStrategyBase {
    protected click$: Observable<[boolean, Event]>;
    readonly show$: Observable<Event>;
    readonly hide$: Observable<Event>;
}
/**
 * Creates show and hide event streams.
 * Fires open event when a mouse hovers over the host element and stay over at least 100 milliseconds.
 * Fires close event when the mouse leaves the host element and stops out of the host and popover container.
 * */
export declare class NbHoverTriggerStrategy extends NbTriggerStrategyBase {
    show$: Observable<Event>;
    hide$: Observable<Event>;
}
/**
 * Creates show and hide event streams.
 * Fires open event when a mouse hovers over the host element and stay over at least 100 milliseconds.
 * Fires close event when the mouse leaves the host element.
 * */
export declare class NbHintTriggerStrategy extends NbTriggerStrategyBase {
    show$: Observable<Event>;
    hide$: Observable<Event>;
}
/**
 * Creates show and hide event streams.
 * Fires open event when a focus is on the host element and stay over at least 100 milliseconds.
 * Fires close event when the focus leaves the host element.
 * */
export declare class NbFocusTriggerStrategy extends NbTriggerStrategyBase {
    protected focusOut$: Observable<Event>;
    protected clickIn$: Observable<Event>;
    protected clickOut$: Observable<Event>;
    protected tabKeyPress$: Observable<Event>;
    show$: Observable<Event>;
    hide$: Observable<Event>;
}
/**
 * Creates empty show and hide event streams.
 * */
export declare class NbNoopTriggerStrategy extends NbTriggerStrategyBase {
    show$: Observable<Event>;
    hide$: Observable<Event>;
}
export declare class NbTriggerStrategyBuilderService {
    protected _document: any;
    protected _host: HTMLElement;
    protected _container: () => ComponentRef<any>;
    protected _trigger: NbTrigger;
    constructor(_document: any);
    trigger(trigger: NbTrigger): this;
    host(host: HTMLElement): this;
    container(container: () => ComponentRef<any>): this;
    build(): NbTriggerStrategy;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<NbTriggerStrategyBuilderService, never>;
    static ɵprov: ɵngcc0.ɵɵInjectableDef<NbTriggerStrategyBuilderService>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib3ZlcmxheS10cmlnZ2VyLmQudHMiLCJzb3VyY2VzIjpbIm92ZXJsYXktdHJpZ2dlci5kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQStGQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBvbmVudFJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuZXhwb3J0IGRlY2xhcmUgdHlwZSBOYlRyaWdnZXJWYWx1ZXMgPSAnbm9vcCcgfCAnY2xpY2snIHwgJ2hvdmVyJyB8ICdoaW50JyB8ICdmb2N1cyc7XG5leHBvcnQgZGVjbGFyZSBlbnVtIE5iVHJpZ2dlciB7XG4gICAgTk9PUCA9IFwibm9vcFwiLFxuICAgIENMSUNLID0gXCJjbGlja1wiLFxuICAgIEhPVkVSID0gXCJob3ZlclwiLFxuICAgIEhJTlQgPSBcImhpbnRcIixcbiAgICBGT0NVUyA9IFwiZm9jdXNcIlxufVxuLyoqXG4gKiBQcm92aWRlcyBlbnRpdHkgd2l0aCB0d28gZXZlbnQgc3RyZWFtOiBzaG93IGFuZCBoaWRlLlxuICogRWFjaCBzdHJlYW0gcHJvdmlkZXMgZGlmZmVyZW50IGV2ZW50cyBkZXBlbmRzIG9uIGltcGxlbWVudGF0aW9uLlxuICogV2UgaGF2ZSB0aHJlZSBtYWluIHRyaWdnZXIgc3RyYXRlZ2llczogY2xpY2ssIGhpbnQgYW5kIGhvdmVyLlxuICogKi9cbmV4cG9ydCBpbnRlcmZhY2UgTmJUcmlnZ2VyU3RyYXRlZ3kge1xuICAgIHNob3ckOiBPYnNlcnZhYmxlPG5ldmVyIHwgRXZlbnQ+O1xuICAgIGhpZGUkOiBPYnNlcnZhYmxlPG5ldmVyIHwgRXZlbnQ+O1xuICAgIGRlc3Ryb3koKTogYW55O1xufVxuLyoqXG4gKiBUT0RPIG1heWJlIHdlIGhhdmUgdG8gdXNlIHJlbmRlcmVyLmxpc3RlbiBpbnN0ZWFkIG9mIG9ic2VydmFibGVGcm9tRXZlbnQ/XG4gKiBSZW5kZXJlciBwcm92aWRlcyBjYXBhYmlsaXR5IHVzZSBpdCBpbiBzZXJ2aWNlIHdvcmtlciwgc3NyIGFuZCBzbyBvbi5cbiAqICovXG5leHBvcnQgZGVjbGFyZSBhYnN0cmFjdCBjbGFzcyBOYlRyaWdnZXJTdHJhdGVneUJhc2UgaW1wbGVtZW50cyBOYlRyaWdnZXJTdHJhdGVneSB7XG4gICAgcHJvdGVjdGVkIGRvY3VtZW50OiBEb2N1bWVudDtcbiAgICBwcm90ZWN0ZWQgaG9zdDogSFRNTEVsZW1lbnQ7XG4gICAgcHJvdGVjdGVkIGNvbnRhaW5lcjogKCkgPT4gQ29tcG9uZW50UmVmPGFueT47XG4gICAgZGVzdHJveSgpOiB2b2lkO1xuICAgIHByb3RlY3RlZCBkZXN0cm95ZWQkOiBTdWJqZWN0PHVua25vd24+O1xuICAgIHByb3RlY3RlZCBpc05vdE9uSG9zdE9yQ29udGFpbmVyKGV2ZW50OiBFdmVudCk6IGJvb2xlYW47XG4gICAgcHJvdGVjdGVkIGlzT25Ib3N0T3JDb250YWluZXIoZXZlbnQ6IEV2ZW50KTogYm9vbGVhbjtcbiAgICBwcm90ZWN0ZWQgaXNPbkhvc3QoeyB0YXJnZXQgfTogRXZlbnQpOiBib29sZWFuO1xuICAgIHByb3RlY3RlZCBpc09uQ29udGFpbmVyKHsgdGFyZ2V0IH06IEV2ZW50KTogYm9vbGVhbjtcbiAgICBhYnN0cmFjdCBzaG93JDogT2JzZXJ2YWJsZTxFdmVudD47XG4gICAgYWJzdHJhY3QgaGlkZSQ6IE9ic2VydmFibGU8RXZlbnQ+O1xuICAgIGNvbnN0cnVjdG9yKGRvY3VtZW50OiBEb2N1bWVudCwgaG9zdDogSFRNTEVsZW1lbnQsIGNvbnRhaW5lcjogKCkgPT4gQ29tcG9uZW50UmVmPGFueT4pO1xufVxuLyoqXG4gKiBDcmVhdGVzIHNob3cgYW5kIGhpZGUgZXZlbnQgc3RyZWFtcy5cbiAqIEZpcmVzIHRvZ2dsZSBldmVudCB3aGVuIHRoZSBjbGljayB3YXMgcGVyZm9ybWVkIG9uIHRoZSBob3N0IGVsZW1lbnQuXG4gKiBGaXJlcyBjbG9zZSBldmVudCB3aGVuIHRoZSBjbGljayB3YXMgcGVyZm9ybWVkIG9uIHRoZSBkb2N1bWVudCBidXRcbiAqIG5vdCBvbiB0aGUgaG9zdCBvciBjb250YWluZXIuXG4gKiAqL1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgTmJDbGlja1RyaWdnZXJTdHJhdGVneSBleHRlbmRzIE5iVHJpZ2dlclN0cmF0ZWd5QmFzZSB7XG4gICAgcHJvdGVjdGVkIGNsaWNrJDogT2JzZXJ2YWJsZTxbYm9vbGVhbiwgRXZlbnRdPjtcbiAgICByZWFkb25seSBzaG93JDogT2JzZXJ2YWJsZTxFdmVudD47XG4gICAgcmVhZG9ubHkgaGlkZSQ6IE9ic2VydmFibGU8RXZlbnQ+O1xufVxuLyoqXG4gKiBDcmVhdGVzIHNob3cgYW5kIGhpZGUgZXZlbnQgc3RyZWFtcy5cbiAqIEZpcmVzIG9wZW4gZXZlbnQgd2hlbiBhIG1vdXNlIGhvdmVycyBvdmVyIHRoZSBob3N0IGVsZW1lbnQgYW5kIHN0YXkgb3ZlciBhdCBsZWFzdCAxMDAgbWlsbGlzZWNvbmRzLlxuICogRmlyZXMgY2xvc2UgZXZlbnQgd2hlbiB0aGUgbW91c2UgbGVhdmVzIHRoZSBob3N0IGVsZW1lbnQgYW5kIHN0b3BzIG91dCBvZiB0aGUgaG9zdCBhbmQgcG9wb3ZlciBjb250YWluZXIuXG4gKiAqL1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgTmJIb3ZlclRyaWdnZXJTdHJhdGVneSBleHRlbmRzIE5iVHJpZ2dlclN0cmF0ZWd5QmFzZSB7XG4gICAgc2hvdyQ6IE9ic2VydmFibGU8RXZlbnQ+O1xuICAgIGhpZGUkOiBPYnNlcnZhYmxlPEV2ZW50Pjtcbn1cbi8qKlxuICogQ3JlYXRlcyBzaG93IGFuZCBoaWRlIGV2ZW50IHN0cmVhbXMuXG4gKiBGaXJlcyBvcGVuIGV2ZW50IHdoZW4gYSBtb3VzZSBob3ZlcnMgb3ZlciB0aGUgaG9zdCBlbGVtZW50IGFuZCBzdGF5IG92ZXIgYXQgbGVhc3QgMTAwIG1pbGxpc2Vjb25kcy5cbiAqIEZpcmVzIGNsb3NlIGV2ZW50IHdoZW4gdGhlIG1vdXNlIGxlYXZlcyB0aGUgaG9zdCBlbGVtZW50LlxuICogKi9cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIE5iSGludFRyaWdnZXJTdHJhdGVneSBleHRlbmRzIE5iVHJpZ2dlclN0cmF0ZWd5QmFzZSB7XG4gICAgc2hvdyQ6IE9ic2VydmFibGU8RXZlbnQ+O1xuICAgIGhpZGUkOiBPYnNlcnZhYmxlPEV2ZW50Pjtcbn1cbi8qKlxuICogQ3JlYXRlcyBzaG93IGFuZCBoaWRlIGV2ZW50IHN0cmVhbXMuXG4gKiBGaXJlcyBvcGVuIGV2ZW50IHdoZW4gYSBmb2N1cyBpcyBvbiB0aGUgaG9zdCBlbGVtZW50IGFuZCBzdGF5IG92ZXIgYXQgbGVhc3QgMTAwIG1pbGxpc2Vjb25kcy5cbiAqIEZpcmVzIGNsb3NlIGV2ZW50IHdoZW4gdGhlIGZvY3VzIGxlYXZlcyB0aGUgaG9zdCBlbGVtZW50LlxuICogKi9cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIE5iRm9jdXNUcmlnZ2VyU3RyYXRlZ3kgZXh0ZW5kcyBOYlRyaWdnZXJTdHJhdGVneUJhc2Uge1xuICAgIHByb3RlY3RlZCBmb2N1c091dCQ6IE9ic2VydmFibGU8RXZlbnQ+O1xuICAgIHByb3RlY3RlZCBjbGlja0luJDogT2JzZXJ2YWJsZTxFdmVudD47XG4gICAgcHJvdGVjdGVkIGNsaWNrT3V0JDogT2JzZXJ2YWJsZTxFdmVudD47XG4gICAgcHJvdGVjdGVkIHRhYktleVByZXNzJDogT2JzZXJ2YWJsZTxFdmVudD47XG4gICAgc2hvdyQ6IE9ic2VydmFibGU8RXZlbnQ+O1xuICAgIGhpZGUkOiBPYnNlcnZhYmxlPEV2ZW50Pjtcbn1cbi8qKlxuICogQ3JlYXRlcyBlbXB0eSBzaG93IGFuZCBoaWRlIGV2ZW50IHN0cmVhbXMuXG4gKiAqL1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgTmJOb29wVHJpZ2dlclN0cmF0ZWd5IGV4dGVuZHMgTmJUcmlnZ2VyU3RyYXRlZ3lCYXNlIHtcbiAgICBzaG93JDogT2JzZXJ2YWJsZTxFdmVudD47XG4gICAgaGlkZSQ6IE9ic2VydmFibGU8RXZlbnQ+O1xufVxuZXhwb3J0IGRlY2xhcmUgY2xhc3MgTmJUcmlnZ2VyU3RyYXRlZ3lCdWlsZGVyU2VydmljZSB7XG4gICAgcHJvdGVjdGVkIF9kb2N1bWVudDogYW55O1xuICAgIHByb3RlY3RlZCBfaG9zdDogSFRNTEVsZW1lbnQ7XG4gICAgcHJvdGVjdGVkIF9jb250YWluZXI6ICgpID0+IENvbXBvbmVudFJlZjxhbnk+O1xuICAgIHByb3RlY3RlZCBfdHJpZ2dlcjogTmJUcmlnZ2VyO1xuICAgIGNvbnN0cnVjdG9yKF9kb2N1bWVudDogYW55KTtcbiAgICB0cmlnZ2VyKHRyaWdnZXI6IE5iVHJpZ2dlcik6IHRoaXM7XG4gICAgaG9zdChob3N0OiBIVE1MRWxlbWVudCk6IHRoaXM7XG4gICAgY29udGFpbmVyKGNvbnRhaW5lcjogKCkgPT4gQ29tcG9uZW50UmVmPGFueT4pOiB0aGlzO1xuICAgIGJ1aWxkKCk6IE5iVHJpZ2dlclN0cmF0ZWd5O1xufVxuIl19