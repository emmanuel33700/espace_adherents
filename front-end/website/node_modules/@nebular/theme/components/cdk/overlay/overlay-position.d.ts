import { ElementRef } from '@angular/core';
import { Observable } from 'rxjs';
import { NbConnectedPosition, NbFlexibleConnectedPositionStrategy, NbOverlayPositionBuilder, NbOverlayRef, NbPositionStrategy } from './mapping';
import { NbPlatform } from '../platform/platform-service';
import { NbOverlayContainerAdapter } from '../adapter/overlay-container-adapter';
import { NbViewportRulerAdapter } from '../adapter/viewport-ruler-adapter';
import { NbGlobalLogicalPosition } from './position-helper';
import { GlobalPositionStrategy } from '@angular/cdk/overlay';
import * as ɵngcc0 from '@angular/core';
export declare enum NbAdjustment {
    NOOP = "noop",
    CLOCKWISE = "clockwise",
    COUNTERCLOCKWISE = "counterclockwise",
    VERTICAL = "vertical",
    HORIZONTAL = "horizontal"
}
export declare type NbPositionValues = 'top' | 'bottom' | 'left' | 'right' | 'start' | 'end' | 'top-end' | 'top-start' | 'bottom-end' | 'bottom-start' | 'end-top' | 'end-bottom' | 'start-top' | 'start-bottom';
export declare enum NbPosition {
    TOP = "top",
    BOTTOM = "bottom",
    LEFT = "left",
    RIGHT = "right",
    START = "start",
    END = "end",
    TOP_END = "top-end",
    TOP_START = "top-start",
    BOTTOM_END = "bottom-end",
    BOTTOM_START = "bottom-start",
    END_TOP = "end-top",
    END_BOTTOM = "end-bottom",
    START_TOP = "start-top",
    START_BOTTOM = "start-bottom"
}
/**
 * The main idea of the adjustable connected strategy is to provide predefined set of positions for your overlay.
 * You have to provide adjustment and appropriate strategy will be chosen in runtime.
 * */
export declare class NbAdjustableConnectedPositionStrategy extends NbFlexibleConnectedPositionStrategy implements NbPositionStrategy {
    protected _position: NbPosition;
    protected _offset: number;
    protected _adjustment: NbAdjustment;
    protected appliedPositions: {
        key: NbPosition;
        connectedPosition: NbConnectedPosition;
    }[];
    readonly positionChange: Observable<NbPosition>;
    attach(overlayRef: NbOverlayRef): void;
    apply(): void;
    position(position: NbPosition): this;
    adjustment(adjustment: NbAdjustment): this;
    offset(offset: number): this;
    protected applyPositions(): void;
    protected createPositions(): NbPosition[];
    protected persistChosenPositions(positions: NbPosition[]): void;
    protected reorderPreferredPositions(positions: NbPosition[]): NbPosition[];
    protected mapToLogicalPosition(position: NbPosition): NbPosition;
}
export declare class NbGlobalPositionStrategy extends GlobalPositionStrategy {
    position(position: NbGlobalLogicalPosition): this;
}
export declare class NbPositionBuilderService {
    protected document: any;
    protected viewportRuler: NbViewportRulerAdapter;
    protected platform: NbPlatform;
    protected positionBuilder: NbOverlayPositionBuilder;
    protected overlayContainer: NbOverlayContainerAdapter;
    constructor(document: any, viewportRuler: NbViewportRulerAdapter, platform: NbPlatform, positionBuilder: NbOverlayPositionBuilder, overlayContainer: NbOverlayContainerAdapter);
    global(): NbGlobalPositionStrategy;
    connectedTo(elementRef: ElementRef): NbAdjustableConnectedPositionStrategy;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<NbPositionBuilderService, never>;
    static ɵprov: ɵngcc0.ɵɵInjectableDef<NbPositionBuilderService>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib3ZlcmxheS1wb3NpdGlvbi5kLnRzIiwic291cmNlcyI6WyJvdmVybGF5LXBvc2l0aW9uLmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7OztBQVFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTREQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEVsZW1lbnRSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IE5iQ29ubmVjdGVkUG9zaXRpb24sIE5iRmxleGlibGVDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5LCBOYk92ZXJsYXlQb3NpdGlvbkJ1aWxkZXIsIE5iT3ZlcmxheVJlZiwgTmJQb3NpdGlvblN0cmF0ZWd5IH0gZnJvbSAnLi9tYXBwaW5nJztcbmltcG9ydCB7IE5iUGxhdGZvcm0gfSBmcm9tICcuLi9wbGF0Zm9ybS9wbGF0Zm9ybS1zZXJ2aWNlJztcbmltcG9ydCB7IE5iT3ZlcmxheUNvbnRhaW5lckFkYXB0ZXIgfSBmcm9tICcuLi9hZGFwdGVyL292ZXJsYXktY29udGFpbmVyLWFkYXB0ZXInO1xuaW1wb3J0IHsgTmJWaWV3cG9ydFJ1bGVyQWRhcHRlciB9IGZyb20gJy4uL2FkYXB0ZXIvdmlld3BvcnQtcnVsZXItYWRhcHRlcic7XG5pbXBvcnQgeyBOYkdsb2JhbExvZ2ljYWxQb3NpdGlvbiB9IGZyb20gJy4vcG9zaXRpb24taGVscGVyJztcbmltcG9ydCB7IEdsb2JhbFBvc2l0aW9uU3RyYXRlZ3kgfSBmcm9tICdAYW5ndWxhci9jZGsvb3ZlcmxheSc7XG5leHBvcnQgZGVjbGFyZSBlbnVtIE5iQWRqdXN0bWVudCB7XG4gICAgTk9PUCA9IFwibm9vcFwiLFxuICAgIENMT0NLV0lTRSA9IFwiY2xvY2t3aXNlXCIsXG4gICAgQ09VTlRFUkNMT0NLV0lTRSA9IFwiY291bnRlcmNsb2Nrd2lzZVwiLFxuICAgIFZFUlRJQ0FMID0gXCJ2ZXJ0aWNhbFwiLFxuICAgIEhPUklaT05UQUwgPSBcImhvcml6b250YWxcIlxufVxuZXhwb3J0IGRlY2xhcmUgdHlwZSBOYlBvc2l0aW9uVmFsdWVzID0gJ3RvcCcgfCAnYm90dG9tJyB8ICdsZWZ0JyB8ICdyaWdodCcgfCAnc3RhcnQnIHwgJ2VuZCcgfCAndG9wLWVuZCcgfCAndG9wLXN0YXJ0JyB8ICdib3R0b20tZW5kJyB8ICdib3R0b20tc3RhcnQnIHwgJ2VuZC10b3AnIHwgJ2VuZC1ib3R0b20nIHwgJ3N0YXJ0LXRvcCcgfCAnc3RhcnQtYm90dG9tJztcbmV4cG9ydCBkZWNsYXJlIGVudW0gTmJQb3NpdGlvbiB7XG4gICAgVE9QID0gXCJ0b3BcIixcbiAgICBCT1RUT00gPSBcImJvdHRvbVwiLFxuICAgIExFRlQgPSBcImxlZnRcIixcbiAgICBSSUdIVCA9IFwicmlnaHRcIixcbiAgICBTVEFSVCA9IFwic3RhcnRcIixcbiAgICBFTkQgPSBcImVuZFwiLFxuICAgIFRPUF9FTkQgPSBcInRvcC1lbmRcIixcbiAgICBUT1BfU1RBUlQgPSBcInRvcC1zdGFydFwiLFxuICAgIEJPVFRPTV9FTkQgPSBcImJvdHRvbS1lbmRcIixcbiAgICBCT1RUT01fU1RBUlQgPSBcImJvdHRvbS1zdGFydFwiLFxuICAgIEVORF9UT1AgPSBcImVuZC10b3BcIixcbiAgICBFTkRfQk9UVE9NID0gXCJlbmQtYm90dG9tXCIsXG4gICAgU1RBUlRfVE9QID0gXCJzdGFydC10b3BcIixcbiAgICBTVEFSVF9CT1RUT00gPSBcInN0YXJ0LWJvdHRvbVwiXG59XG4vKipcbiAqIFRoZSBtYWluIGlkZWEgb2YgdGhlIGFkanVzdGFibGUgY29ubmVjdGVkIHN0cmF0ZWd5IGlzIHRvIHByb3ZpZGUgcHJlZGVmaW5lZCBzZXQgb2YgcG9zaXRpb25zIGZvciB5b3VyIG92ZXJsYXkuXG4gKiBZb3UgaGF2ZSB0byBwcm92aWRlIGFkanVzdG1lbnQgYW5kIGFwcHJvcHJpYXRlIHN0cmF0ZWd5IHdpbGwgYmUgY2hvc2VuIGluIHJ1bnRpbWUuXG4gKiAqL1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgTmJBZGp1c3RhYmxlQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneSBleHRlbmRzIE5iRmxleGlibGVDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5IGltcGxlbWVudHMgTmJQb3NpdGlvblN0cmF0ZWd5IHtcbiAgICBwcm90ZWN0ZWQgX3Bvc2l0aW9uOiBOYlBvc2l0aW9uO1xuICAgIHByb3RlY3RlZCBfb2Zmc2V0OiBudW1iZXI7XG4gICAgcHJvdGVjdGVkIF9hZGp1c3RtZW50OiBOYkFkanVzdG1lbnQ7XG4gICAgcHJvdGVjdGVkIGFwcGxpZWRQb3NpdGlvbnM6IHtcbiAgICAgICAga2V5OiBOYlBvc2l0aW9uO1xuICAgICAgICBjb25uZWN0ZWRQb3NpdGlvbjogTmJDb25uZWN0ZWRQb3NpdGlvbjtcbiAgICB9W107XG4gICAgcmVhZG9ubHkgcG9zaXRpb25DaGFuZ2U6IE9ic2VydmFibGU8TmJQb3NpdGlvbj47XG4gICAgYXR0YWNoKG92ZXJsYXlSZWY6IE5iT3ZlcmxheVJlZik6IHZvaWQ7XG4gICAgYXBwbHkoKTogdm9pZDtcbiAgICBwb3NpdGlvbihwb3NpdGlvbjogTmJQb3NpdGlvbik6IHRoaXM7XG4gICAgYWRqdXN0bWVudChhZGp1c3RtZW50OiBOYkFkanVzdG1lbnQpOiB0aGlzO1xuICAgIG9mZnNldChvZmZzZXQ6IG51bWJlcik6IHRoaXM7XG4gICAgcHJvdGVjdGVkIGFwcGx5UG9zaXRpb25zKCk6IHZvaWQ7XG4gICAgcHJvdGVjdGVkIGNyZWF0ZVBvc2l0aW9ucygpOiBOYlBvc2l0aW9uW107XG4gICAgcHJvdGVjdGVkIHBlcnNpc3RDaG9zZW5Qb3NpdGlvbnMocG9zaXRpb25zOiBOYlBvc2l0aW9uW10pOiB2b2lkO1xuICAgIHByb3RlY3RlZCByZW9yZGVyUHJlZmVycmVkUG9zaXRpb25zKHBvc2l0aW9uczogTmJQb3NpdGlvbltdKTogTmJQb3NpdGlvbltdO1xuICAgIHByb3RlY3RlZCBtYXBUb0xvZ2ljYWxQb3NpdGlvbihwb3NpdGlvbjogTmJQb3NpdGlvbik6IE5iUG9zaXRpb247XG59XG5leHBvcnQgZGVjbGFyZSBjbGFzcyBOYkdsb2JhbFBvc2l0aW9uU3RyYXRlZ3kgZXh0ZW5kcyBHbG9iYWxQb3NpdGlvblN0cmF0ZWd5IHtcbiAgICBwb3NpdGlvbihwb3NpdGlvbjogTmJHbG9iYWxMb2dpY2FsUG9zaXRpb24pOiB0aGlzO1xufVxuZXhwb3J0IGRlY2xhcmUgY2xhc3MgTmJQb3NpdGlvbkJ1aWxkZXJTZXJ2aWNlIHtcbiAgICBwcm90ZWN0ZWQgZG9jdW1lbnQ6IGFueTtcbiAgICBwcm90ZWN0ZWQgdmlld3BvcnRSdWxlcjogTmJWaWV3cG9ydFJ1bGVyQWRhcHRlcjtcbiAgICBwcm90ZWN0ZWQgcGxhdGZvcm06IE5iUGxhdGZvcm07XG4gICAgcHJvdGVjdGVkIHBvc2l0aW9uQnVpbGRlcjogTmJPdmVybGF5UG9zaXRpb25CdWlsZGVyO1xuICAgIHByb3RlY3RlZCBvdmVybGF5Q29udGFpbmVyOiBOYk92ZXJsYXlDb250YWluZXJBZGFwdGVyO1xuICAgIGNvbnN0cnVjdG9yKGRvY3VtZW50OiBhbnksIHZpZXdwb3J0UnVsZXI6IE5iVmlld3BvcnRSdWxlckFkYXB0ZXIsIHBsYXRmb3JtOiBOYlBsYXRmb3JtLCBwb3NpdGlvbkJ1aWxkZXI6IE5iT3ZlcmxheVBvc2l0aW9uQnVpbGRlciwgb3ZlcmxheUNvbnRhaW5lcjogTmJPdmVybGF5Q29udGFpbmVyQWRhcHRlcik7XG4gICAgZ2xvYmFsKCk6IE5iR2xvYmFsUG9zaXRpb25TdHJhdGVneTtcbiAgICBjb25uZWN0ZWRUbyhlbGVtZW50UmVmOiBFbGVtZW50UmVmKTogTmJBZGp1c3RhYmxlQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneTtcbn1cbiJdfQ==