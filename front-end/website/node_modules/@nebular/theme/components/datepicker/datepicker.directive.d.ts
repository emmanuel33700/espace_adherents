import { ElementRef, InjectionToken, OnDestroy, ChangeDetectorRef, Type } from '@angular/core';
import { ControlValueAccessor, ValidationErrors, Validator, ValidatorFn } from '@angular/forms';
import { Observable, Subject } from 'rxjs';
import { NbDateService } from '../calendar-kit/services/date.service';
/**
 * The `NbDatepickerAdapter` instances provide way how to parse, format and validate
 * different date types.
 * */
import * as ɵngcc0 from '@angular/core';
export declare abstract class NbDatepickerAdapter<D> {
    /**
     * Picker component class.
     * */
    abstract picker: Type<any>;
    /**
     * Parse date string according to the format.
     * */
    abstract parse(value: string, format: string): D;
    /**
     * Format date according to the format.
     * */
    abstract format(value: D, format: string): string;
    /**
     * Validates date string according to the passed format.
     * */
    abstract isValid(value: string, format: string): boolean;
}
/**
 * Validators config that will be used by form control to perform proper validation.
 * */
export interface NbPickerValidatorConfig<D> {
    /**
     * Minimum date available in picker.
     * */
    min: D;
    /**
     * Maximum date available in picker.
     * */
    max: D;
    /**
     * Predicate that determines is value available for picking.
     * */
    filter: (D: any) => boolean;
}
/**
 * Datepicker is an control that can pick any values anyway.
 * It has to be bound to the datepicker directive through nbDatepicker input.
 * */
export declare abstract class NbDatepicker<T> {
    /**
     * HTML input element date format.
     * */
    abstract format: string;
    abstract get value(): T;
    abstract set value(value: T);
    abstract get valueChange(): Observable<T>;
    abstract get init(): Observable<void>;
    /**
     * Attaches datepicker to the native input element.
     * */
    abstract attach(hostRef: ElementRef): any;
    /**
     * Returns validator configuration based on the input properties.
     * */
    abstract getValidatorConfig(): NbPickerValidatorConfig<T>;
    abstract show(): any;
    abstract hide(): any;
    abstract shouldHide(): boolean;
    abstract get isShown(): boolean;
    abstract get blur(): Observable<void>;
}
export declare const NB_DATE_ADAPTER: InjectionToken<NbDatepickerAdapter<any>>;
export declare const NB_DATE_SERVICE_OPTIONS: InjectionToken<unknown>;
/**
 * The `NbDatepickerDirective` is form control that gives you ability to select dates and ranges. The datepicker
 * is shown when input receives a `focus` event.
 *
 * ```html
 * <input [nbDatepicker]="datepicker">
 * <nb-datepicker #datepicker></nb-datepicker>
 * ```
 *
 * @stacked-example(Showcase, datepicker/datepicker-showcase.component)
 *
 * ### Installation
 *
 * Import `NbDatepickerModule.forRoot()` to your root module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbDatepickerModule.forRoot(),
 *   ],
 * })
 * export class AppModule { }
 * ```
 * And `NbDatepickerModule` to your feature module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbDatepickerModule,
 *   ],
 * })
 * export class PageModule { }
 * ```
 * ### Usage
 *
 * If you want to use range selection, you have to use `NbRangepickerComponent` instead:
 *
 * ```html
 * <input [nbDatepicker]="rangepicker">
 * <nb-rangepicker #rangepicker></nb-rangepicker>
 * ```
 *
 * Both range and date pickers support all parameters as calendar, so, check `NbCalendarComponent` for additional
 * info.
 *
 * @stacked-example(Range showcase, datepicker/rangepicker-showcase.component)
 *
 * Datepicker is the form control so it can be bound with angular forms through ngModel and form controls.
 *
 * @stacked-example(Forms, datepicker/datepicker-forms.component)
 *
 * `NbDatepickerDirective` may be validated using `min` and `max` dates passed to the datepicker.
 * And `filter` predicate that receives date object and has to return a boolean value.
 *
 * @stacked-example(Validation, datepicker/datepicker-validation.component)
 *
 * The `NbDatepickerComponent` supports date formatting:
 *
 * ```html
 * <input [nbDatepicker]="datepicker">
 * <nb-datepicker #datepicker format="MM\dd\yyyy"></nb-datepicker>
 * ```
 *
 * ## Formatting Issue
 *
 * By default, datepicker uses angulars `LOCALE_ID` token for localization and `DatePipe` for dates formatting.
 * And native `Date.parse(...)` for dates parsing. But native `Date.parse` function doesn't support formats.
 * To provide custom formatting you have to use one of the following packages:
 *
 * - `@nebular/moment` - provides moment date adapter that uses moment for date objects. This means datepicker than
 * will operate only moment date objects. If you want to use it you have to install it: `npm i @nebular/moment`, and
 * import `NbMomentDateModule` from this package.
 *
 * - `@nebular/date-fns` - adapter for popular date-fns library. This way is preferred if you need only date formatting.
 * Because date-fns is treeshakable, tiny and operates native date objects. If you want to use it you have to
 * install it: `npm i @nebular/date-fns`, and import `NbDateFnsDateModule` from this package.
 *
 * ### NbDateFnsDateModule
 *
 * Format is required when using `NbDateFnsDateModule`. You can set it via `format` input on datepicker component:
 * ```html
 * <nb-datepicker format="dd.MM.yyyy"></nb-datepicker>
 * ```
 * Also format can be set globally with `NbDateFnsDateModule.forRoot({ format: 'dd.MM.yyyy' })` and
 * `NbDateFnsDateModule.forChild({ format: 'dd.MM.yyyy' })` methods.
 *
 * Please note to use some of the formatting tokens you also need to pass
 * `{ useAdditionalWeekYearTokens: true, useAdditionalDayOfYearTokens: true }` to date-fns parse and format functions.
 * You can configure options passed this functions by setting `formatOptions` and
 * `parseOptions` of options object passed to `NbDateFnsDateModule.forRoot` and `NbDateFnsDateModule.forChild` methods.
 * ```ts
 * NbDateFnsDateModule.forRoot({
 *   parseOptions: { useAdditionalWeekYearTokens: true, useAdditionalDayOfYearTokens: true },
 *   formatOptions: { useAdditionalWeekYearTokens: true, useAdditionalDayOfYearTokens: true },
 * })
 * ```
 * Further info on `date-fns` formatting tokens could be found at
 * [date-fns docs](https://date-fns.org/v2.0.0-alpha.27/docs/Unicode-Tokens).
 *
 * You can also use `parseOptions` and `formatOptions` to provide locale.
 * ```ts
 * import { eo } from 'date-fns/locale';
 *
 * @NgModule({
 *   imports: [
 *     NbDateFnsDateModule.forRoot({
 *       parseOptions: { locale: eo },
 *       formatOptions: { locale: eo },
 *     }),
 *   ],
 * })
 * ```
 *
 * @styles
 *
 * datepicker-background-color:
 * datepicker-border-color:
 * datepicker-border-style:
 * datepicker-border-width:
 * datepicker-border-radius:
 * datepicker-shadow:
 * */
export declare class NbDatepickerDirective<D> implements OnDestroy, ControlValueAccessor, Validator {
    protected document: any;
    protected datepickerAdapters: NbDatepickerAdapter<D>[];
    protected hostRef: ElementRef;
    protected dateService: NbDateService<D>;
    protected changeDetector: ChangeDetectorRef;
    /**
     * Provides datepicker component.
     * */
    set setPicker(picker: NbDatepicker<D>);
    /**
     * Datepicker adapter.
     * */
    protected datepickerAdapter: NbDatepickerAdapter<D>;
    /**
     * Datepicker instance.
     * */
    protected picker: NbDatepicker<D>;
    protected destroy$: Subject<void>;
    protected isDatepickerReady: boolean;
    protected queue: D | undefined;
    protected onChange: (D: any) => void;
    protected onTouched: () => void;
    /**
     * Form control validators will be called in validators context, so, we need to bind them.
     * */
    protected validator: ValidatorFn;
    constructor(document: any, datepickerAdapters: NbDatepickerAdapter<D>[], hostRef: ElementRef, dateService: NbDateService<D>, changeDetector: ChangeDetectorRef);
    /**
     * Returns html input element.
     * */
    get input(): HTMLInputElement;
    /**
     * Returns host input value.
     * */
    get inputValue(): string;
    ngOnDestroy(): void;
    /**
     * Writes value in picker and html input element.
     * */
    writeValue(value: D): void;
    registerOnChange(fn: any): void;
    registerOnTouched(fn: any): void;
    setDisabledState(isDisabled: boolean): void;
    /**
     * Form control validation based on picker validator config.
     * */
    validate(): ValidationErrors | null;
    /**
     * Hides picker, focuses the input
     */
    protected hidePicker(): void;
    /**
     * Validates that we can parse value correctly.
     * */
    protected parseValidator(): ValidationErrors | null;
    /**
     * Validates passed value is greater than min.
     * */
    protected minValidator(): ValidationErrors | null;
    /**
     * Validates passed value is smaller than max.
     * */
    protected maxValidator(): ValidationErrors | null;
    /**
     * Validates passed value satisfy the filter.
     * */
    protected filterValidator(): ValidationErrors | null;
    /**
     * Chooses datepicker adapter based on passed picker component.
     * */
    protected chooseDatepickerAdapter(): void;
    /**
     * Attaches picker to the host input element and subscribes on value changes.
     * */
    protected setupPicker(): void;
    protected writePicker(value: D): void;
    protected writeInput(value: D): void;
    /**
     * Validates if no datepicker adapter provided.
     * */
    protected noDatepickerAdapterProvided(): boolean;
    protected subscribeOnInputChange(): void;
    /**
     * Parses input value and write if it isn't null.
     * */
    protected handleInputChange(value: string): void;
    protected parseInputValue(value: any): D | null;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<NbDatepickerDirective<any>, never>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<NbDatepickerDirective<any>, "input[nbDatepicker]", never, { "setPicker": "nbDatepicker"; }, {}, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZXBpY2tlci5kaXJlY3RpdmUuZC50cyIsInNvdXJjZXMiOlsiZGF0ZXBpY2tlci5kaXJlY3RpdmUuZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7O0FBUUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWtSQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEVsZW1lbnRSZWYsIEluamVjdGlvblRva2VuLCBPbkRlc3Ryb3ksIENoYW5nZURldGVjdG9yUmVmLCBUeXBlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb250cm9sVmFsdWVBY2Nlc3NvciwgVmFsaWRhdGlvbkVycm9ycywgVmFsaWRhdG9yLCBWYWxpZGF0b3JGbiB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IE9ic2VydmFibGUsIFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IE5iRGF0ZVNlcnZpY2UgfSBmcm9tICcuLi9jYWxlbmRhci1raXQvc2VydmljZXMvZGF0ZS5zZXJ2aWNlJztcbi8qKlxuICogVGhlIGBOYkRhdGVwaWNrZXJBZGFwdGVyYCBpbnN0YW5jZXMgcHJvdmlkZSB3YXkgaG93IHRvIHBhcnNlLCBmb3JtYXQgYW5kIHZhbGlkYXRlXG4gKiBkaWZmZXJlbnQgZGF0ZSB0eXBlcy5cbiAqICovXG5leHBvcnQgZGVjbGFyZSBhYnN0cmFjdCBjbGFzcyBOYkRhdGVwaWNrZXJBZGFwdGVyPEQ+IHtcbiAgICAvKipcbiAgICAgKiBQaWNrZXIgY29tcG9uZW50IGNsYXNzLlxuICAgICAqICovXG4gICAgYWJzdHJhY3QgcGlja2VyOiBUeXBlPGFueT47XG4gICAgLyoqXG4gICAgICogUGFyc2UgZGF0ZSBzdHJpbmcgYWNjb3JkaW5nIHRvIHRoZSBmb3JtYXQuXG4gICAgICogKi9cbiAgICBhYnN0cmFjdCBwYXJzZSh2YWx1ZTogc3RyaW5nLCBmb3JtYXQ6IHN0cmluZyk6IEQ7XG4gICAgLyoqXG4gICAgICogRm9ybWF0IGRhdGUgYWNjb3JkaW5nIHRvIHRoZSBmb3JtYXQuXG4gICAgICogKi9cbiAgICBhYnN0cmFjdCBmb3JtYXQodmFsdWU6IEQsIGZvcm1hdDogc3RyaW5nKTogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlcyBkYXRlIHN0cmluZyBhY2NvcmRpbmcgdG8gdGhlIHBhc3NlZCBmb3JtYXQuXG4gICAgICogKi9cbiAgICBhYnN0cmFjdCBpc1ZhbGlkKHZhbHVlOiBzdHJpbmcsIGZvcm1hdDogc3RyaW5nKTogYm9vbGVhbjtcbn1cbi8qKlxuICogVmFsaWRhdG9ycyBjb25maWcgdGhhdCB3aWxsIGJlIHVzZWQgYnkgZm9ybSBjb250cm9sIHRvIHBlcmZvcm0gcHJvcGVyIHZhbGlkYXRpb24uXG4gKiAqL1xuZXhwb3J0IGludGVyZmFjZSBOYlBpY2tlclZhbGlkYXRvckNvbmZpZzxEPiB7XG4gICAgLyoqXG4gICAgICogTWluaW11bSBkYXRlIGF2YWlsYWJsZSBpbiBwaWNrZXIuXG4gICAgICogKi9cbiAgICBtaW46IEQ7XG4gICAgLyoqXG4gICAgICogTWF4aW11bSBkYXRlIGF2YWlsYWJsZSBpbiBwaWNrZXIuXG4gICAgICogKi9cbiAgICBtYXg6IEQ7XG4gICAgLyoqXG4gICAgICogUHJlZGljYXRlIHRoYXQgZGV0ZXJtaW5lcyBpcyB2YWx1ZSBhdmFpbGFibGUgZm9yIHBpY2tpbmcuXG4gICAgICogKi9cbiAgICBmaWx0ZXI6IChEOiBhbnkpID0+IGJvb2xlYW47XG59XG4vKipcbiAqIERhdGVwaWNrZXIgaXMgYW4gY29udHJvbCB0aGF0IGNhbiBwaWNrIGFueSB2YWx1ZXMgYW55d2F5LlxuICogSXQgaGFzIHRvIGJlIGJvdW5kIHRvIHRoZSBkYXRlcGlja2VyIGRpcmVjdGl2ZSB0aHJvdWdoIG5iRGF0ZXBpY2tlciBpbnB1dC5cbiAqICovXG5leHBvcnQgZGVjbGFyZSBhYnN0cmFjdCBjbGFzcyBOYkRhdGVwaWNrZXI8VD4ge1xuICAgIC8qKlxuICAgICAqIEhUTUwgaW5wdXQgZWxlbWVudCBkYXRlIGZvcm1hdC5cbiAgICAgKiAqL1xuICAgIGFic3RyYWN0IGZvcm1hdDogc3RyaW5nO1xuICAgIGFic3RyYWN0IGdldCB2YWx1ZSgpOiBUO1xuICAgIGFic3RyYWN0IHNldCB2YWx1ZSh2YWx1ZTogVCk7XG4gICAgYWJzdHJhY3QgZ2V0IHZhbHVlQ2hhbmdlKCk6IE9ic2VydmFibGU8VD47XG4gICAgYWJzdHJhY3QgZ2V0IGluaXQoKTogT2JzZXJ2YWJsZTx2b2lkPjtcbiAgICAvKipcbiAgICAgKiBBdHRhY2hlcyBkYXRlcGlja2VyIHRvIHRoZSBuYXRpdmUgaW5wdXQgZWxlbWVudC5cbiAgICAgKiAqL1xuICAgIGFic3RyYWN0IGF0dGFjaChob3N0UmVmOiBFbGVtZW50UmVmKTogYW55O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdmFsaWRhdG9yIGNvbmZpZ3VyYXRpb24gYmFzZWQgb24gdGhlIGlucHV0IHByb3BlcnRpZXMuXG4gICAgICogKi9cbiAgICBhYnN0cmFjdCBnZXRWYWxpZGF0b3JDb25maWcoKTogTmJQaWNrZXJWYWxpZGF0b3JDb25maWc8VD47XG4gICAgYWJzdHJhY3Qgc2hvdygpOiBhbnk7XG4gICAgYWJzdHJhY3QgaGlkZSgpOiBhbnk7XG4gICAgYWJzdHJhY3Qgc2hvdWxkSGlkZSgpOiBib29sZWFuO1xuICAgIGFic3RyYWN0IGdldCBpc1Nob3duKCk6IGJvb2xlYW47XG4gICAgYWJzdHJhY3QgZ2V0IGJsdXIoKTogT2JzZXJ2YWJsZTx2b2lkPjtcbn1cbmV4cG9ydCBkZWNsYXJlIGNvbnN0IE5CX0RBVEVfQURBUFRFUjogSW5qZWN0aW9uVG9rZW48TmJEYXRlcGlja2VyQWRhcHRlcjxhbnk+PjtcbmV4cG9ydCBkZWNsYXJlIGNvbnN0IE5CX0RBVEVfU0VSVklDRV9PUFRJT05TOiBJbmplY3Rpb25Ub2tlbjx1bmtub3duPjtcbi8qKlxuICogVGhlIGBOYkRhdGVwaWNrZXJEaXJlY3RpdmVgIGlzIGZvcm0gY29udHJvbCB0aGF0IGdpdmVzIHlvdSBhYmlsaXR5IHRvIHNlbGVjdCBkYXRlcyBhbmQgcmFuZ2VzLiBUaGUgZGF0ZXBpY2tlclxuICogaXMgc2hvd24gd2hlbiBpbnB1dCByZWNlaXZlcyBhIGBmb2N1c2AgZXZlbnQuXG4gKlxuICogYGBgaHRtbFxuICogPGlucHV0IFtuYkRhdGVwaWNrZXJdPVwiZGF0ZXBpY2tlclwiPlxuICogPG5iLWRhdGVwaWNrZXIgI2RhdGVwaWNrZXI+PC9uYi1kYXRlcGlja2VyPlxuICogYGBgXG4gKlxuICogQHN0YWNrZWQtZXhhbXBsZShTaG93Y2FzZSwgZGF0ZXBpY2tlci9kYXRlcGlja2VyLXNob3djYXNlLmNvbXBvbmVudClcbiAqXG4gKiAjIyMgSW5zdGFsbGF0aW9uXG4gKlxuICogSW1wb3J0IGBOYkRhdGVwaWNrZXJNb2R1bGUuZm9yUm9vdCgpYCB0byB5b3VyIHJvb3QgbW9kdWxlLlxuICogYGBgdHNcbiAqIEBOZ01vZHVsZSh7XG4gKiAgIGltcG9ydHM6IFtcbiAqICAgICAvLyAuLi5cbiAqICAgICBOYkRhdGVwaWNrZXJNb2R1bGUuZm9yUm9vdCgpLFxuICogICBdLFxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBBcHBNb2R1bGUgeyB9XG4gKiBgYGBcbiAqIEFuZCBgTmJEYXRlcGlja2VyTW9kdWxlYCB0byB5b3VyIGZlYXR1cmUgbW9kdWxlLlxuICogYGBgdHNcbiAqIEBOZ01vZHVsZSh7XG4gKiAgIGltcG9ydHM6IFtcbiAqICAgICAvLyAuLi5cbiAqICAgICBOYkRhdGVwaWNrZXJNb2R1bGUsXG4gKiAgIF0sXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIFBhZ2VNb2R1bGUgeyB9XG4gKiBgYGBcbiAqICMjIyBVc2FnZVxuICpcbiAqIElmIHlvdSB3YW50IHRvIHVzZSByYW5nZSBzZWxlY3Rpb24sIHlvdSBoYXZlIHRvIHVzZSBgTmJSYW5nZXBpY2tlckNvbXBvbmVudGAgaW5zdGVhZDpcbiAqXG4gKiBgYGBodG1sXG4gKiA8aW5wdXQgW25iRGF0ZXBpY2tlcl09XCJyYW5nZXBpY2tlclwiPlxuICogPG5iLXJhbmdlcGlja2VyICNyYW5nZXBpY2tlcj48L25iLXJhbmdlcGlja2VyPlxuICogYGBgXG4gKlxuICogQm90aCByYW5nZSBhbmQgZGF0ZSBwaWNrZXJzIHN1cHBvcnQgYWxsIHBhcmFtZXRlcnMgYXMgY2FsZW5kYXIsIHNvLCBjaGVjayBgTmJDYWxlbmRhckNvbXBvbmVudGAgZm9yIGFkZGl0aW9uYWxcbiAqIGluZm8uXG4gKlxuICogQHN0YWNrZWQtZXhhbXBsZShSYW5nZSBzaG93Y2FzZSwgZGF0ZXBpY2tlci9yYW5nZXBpY2tlci1zaG93Y2FzZS5jb21wb25lbnQpXG4gKlxuICogRGF0ZXBpY2tlciBpcyB0aGUgZm9ybSBjb250cm9sIHNvIGl0IGNhbiBiZSBib3VuZCB3aXRoIGFuZ3VsYXIgZm9ybXMgdGhyb3VnaCBuZ01vZGVsIGFuZCBmb3JtIGNvbnRyb2xzLlxuICpcbiAqIEBzdGFja2VkLWV4YW1wbGUoRm9ybXMsIGRhdGVwaWNrZXIvZGF0ZXBpY2tlci1mb3Jtcy5jb21wb25lbnQpXG4gKlxuICogYE5iRGF0ZXBpY2tlckRpcmVjdGl2ZWAgbWF5IGJlIHZhbGlkYXRlZCB1c2luZyBgbWluYCBhbmQgYG1heGAgZGF0ZXMgcGFzc2VkIHRvIHRoZSBkYXRlcGlja2VyLlxuICogQW5kIGBmaWx0ZXJgIHByZWRpY2F0ZSB0aGF0IHJlY2VpdmVzIGRhdGUgb2JqZWN0IGFuZCBoYXMgdG8gcmV0dXJuIGEgYm9vbGVhbiB2YWx1ZS5cbiAqXG4gKiBAc3RhY2tlZC1leGFtcGxlKFZhbGlkYXRpb24sIGRhdGVwaWNrZXIvZGF0ZXBpY2tlci12YWxpZGF0aW9uLmNvbXBvbmVudClcbiAqXG4gKiBUaGUgYE5iRGF0ZXBpY2tlckNvbXBvbmVudGAgc3VwcG9ydHMgZGF0ZSBmb3JtYXR0aW5nOlxuICpcbiAqIGBgYGh0bWxcbiAqIDxpbnB1dCBbbmJEYXRlcGlja2VyXT1cImRhdGVwaWNrZXJcIj5cbiAqIDxuYi1kYXRlcGlja2VyICNkYXRlcGlja2VyIGZvcm1hdD1cIk1NXFxkZFxceXl5eVwiPjwvbmItZGF0ZXBpY2tlcj5cbiAqIGBgYFxuICpcbiAqICMjIEZvcm1hdHRpbmcgSXNzdWVcbiAqXG4gKiBCeSBkZWZhdWx0LCBkYXRlcGlja2VyIHVzZXMgYW5ndWxhcnMgYExPQ0FMRV9JRGAgdG9rZW4gZm9yIGxvY2FsaXphdGlvbiBhbmQgYERhdGVQaXBlYCBmb3IgZGF0ZXMgZm9ybWF0dGluZy5cbiAqIEFuZCBuYXRpdmUgYERhdGUucGFyc2UoLi4uKWAgZm9yIGRhdGVzIHBhcnNpbmcuIEJ1dCBuYXRpdmUgYERhdGUucGFyc2VgIGZ1bmN0aW9uIGRvZXNuJ3Qgc3VwcG9ydCBmb3JtYXRzLlxuICogVG8gcHJvdmlkZSBjdXN0b20gZm9ybWF0dGluZyB5b3UgaGF2ZSB0byB1c2Ugb25lIG9mIHRoZSBmb2xsb3dpbmcgcGFja2FnZXM6XG4gKlxuICogLSBgQG5lYnVsYXIvbW9tZW50YCAtIHByb3ZpZGVzIG1vbWVudCBkYXRlIGFkYXB0ZXIgdGhhdCB1c2VzIG1vbWVudCBmb3IgZGF0ZSBvYmplY3RzLiBUaGlzIG1lYW5zIGRhdGVwaWNrZXIgdGhhblxuICogd2lsbCBvcGVyYXRlIG9ubHkgbW9tZW50IGRhdGUgb2JqZWN0cy4gSWYgeW91IHdhbnQgdG8gdXNlIGl0IHlvdSBoYXZlIHRvIGluc3RhbGwgaXQ6IGBucG0gaSBAbmVidWxhci9tb21lbnRgLCBhbmRcbiAqIGltcG9ydCBgTmJNb21lbnREYXRlTW9kdWxlYCBmcm9tIHRoaXMgcGFja2FnZS5cbiAqXG4gKiAtIGBAbmVidWxhci9kYXRlLWZuc2AgLSBhZGFwdGVyIGZvciBwb3B1bGFyIGRhdGUtZm5zIGxpYnJhcnkuIFRoaXMgd2F5IGlzIHByZWZlcnJlZCBpZiB5b3UgbmVlZCBvbmx5IGRhdGUgZm9ybWF0dGluZy5cbiAqIEJlY2F1c2UgZGF0ZS1mbnMgaXMgdHJlZXNoYWthYmxlLCB0aW55IGFuZCBvcGVyYXRlcyBuYXRpdmUgZGF0ZSBvYmplY3RzLiBJZiB5b3Ugd2FudCB0byB1c2UgaXQgeW91IGhhdmUgdG9cbiAqIGluc3RhbGwgaXQ6IGBucG0gaSBAbmVidWxhci9kYXRlLWZuc2AsIGFuZCBpbXBvcnQgYE5iRGF0ZUZuc0RhdGVNb2R1bGVgIGZyb20gdGhpcyBwYWNrYWdlLlxuICpcbiAqICMjIyBOYkRhdGVGbnNEYXRlTW9kdWxlXG4gKlxuICogRm9ybWF0IGlzIHJlcXVpcmVkIHdoZW4gdXNpbmcgYE5iRGF0ZUZuc0RhdGVNb2R1bGVgLiBZb3UgY2FuIHNldCBpdCB2aWEgYGZvcm1hdGAgaW5wdXQgb24gZGF0ZXBpY2tlciBjb21wb25lbnQ6XG4gKiBgYGBodG1sXG4gKiA8bmItZGF0ZXBpY2tlciBmb3JtYXQ9XCJkZC5NTS55eXl5XCI+PC9uYi1kYXRlcGlja2VyPlxuICogYGBgXG4gKiBBbHNvIGZvcm1hdCBjYW4gYmUgc2V0IGdsb2JhbGx5IHdpdGggYE5iRGF0ZUZuc0RhdGVNb2R1bGUuZm9yUm9vdCh7IGZvcm1hdDogJ2RkLk1NLnl5eXknIH0pYCBhbmRcbiAqIGBOYkRhdGVGbnNEYXRlTW9kdWxlLmZvckNoaWxkKHsgZm9ybWF0OiAnZGQuTU0ueXl5eScgfSlgIG1ldGhvZHMuXG4gKlxuICogUGxlYXNlIG5vdGUgdG8gdXNlIHNvbWUgb2YgdGhlIGZvcm1hdHRpbmcgdG9rZW5zIHlvdSBhbHNvIG5lZWQgdG8gcGFzc1xuICogYHsgdXNlQWRkaXRpb25hbFdlZWtZZWFyVG9rZW5zOiB0cnVlLCB1c2VBZGRpdGlvbmFsRGF5T2ZZZWFyVG9rZW5zOiB0cnVlIH1gIHRvIGRhdGUtZm5zIHBhcnNlIGFuZCBmb3JtYXQgZnVuY3Rpb25zLlxuICogWW91IGNhbiBjb25maWd1cmUgb3B0aW9ucyBwYXNzZWQgdGhpcyBmdW5jdGlvbnMgYnkgc2V0dGluZyBgZm9ybWF0T3B0aW9uc2AgYW5kXG4gKiBgcGFyc2VPcHRpb25zYCBvZiBvcHRpb25zIG9iamVjdCBwYXNzZWQgdG8gYE5iRGF0ZUZuc0RhdGVNb2R1bGUuZm9yUm9vdGAgYW5kIGBOYkRhdGVGbnNEYXRlTW9kdWxlLmZvckNoaWxkYCBtZXRob2RzLlxuICogYGBgdHNcbiAqIE5iRGF0ZUZuc0RhdGVNb2R1bGUuZm9yUm9vdCh7XG4gKiAgIHBhcnNlT3B0aW9uczogeyB1c2VBZGRpdGlvbmFsV2Vla1llYXJUb2tlbnM6IHRydWUsIHVzZUFkZGl0aW9uYWxEYXlPZlllYXJUb2tlbnM6IHRydWUgfSxcbiAqICAgZm9ybWF0T3B0aW9uczogeyB1c2VBZGRpdGlvbmFsV2Vla1llYXJUb2tlbnM6IHRydWUsIHVzZUFkZGl0aW9uYWxEYXlPZlllYXJUb2tlbnM6IHRydWUgfSxcbiAqIH0pXG4gKiBgYGBcbiAqIEZ1cnRoZXIgaW5mbyBvbiBgZGF0ZS1mbnNgIGZvcm1hdHRpbmcgdG9rZW5zIGNvdWxkIGJlIGZvdW5kIGF0XG4gKiBbZGF0ZS1mbnMgZG9jc10oaHR0cHM6Ly9kYXRlLWZucy5vcmcvdjIuMC4wLWFscGhhLjI3L2RvY3MvVW5pY29kZS1Ub2tlbnMpLlxuICpcbiAqIFlvdSBjYW4gYWxzbyB1c2UgYHBhcnNlT3B0aW9uc2AgYW5kIGBmb3JtYXRPcHRpb25zYCB0byBwcm92aWRlIGxvY2FsZS5cbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBlbyB9IGZyb20gJ2RhdGUtZm5zL2xvY2FsZSc7XG4gKlxuICogQE5nTW9kdWxlKHtcbiAqICAgaW1wb3J0czogW1xuICogICAgIE5iRGF0ZUZuc0RhdGVNb2R1bGUuZm9yUm9vdCh7XG4gKiAgICAgICBwYXJzZU9wdGlvbnM6IHsgbG9jYWxlOiBlbyB9LFxuICogICAgICAgZm9ybWF0T3B0aW9uczogeyBsb2NhbGU6IGVvIH0sXG4gKiAgICAgfSksXG4gKiAgIF0sXG4gKiB9KVxuICogYGBgXG4gKlxuICogQHN0eWxlc1xuICpcbiAqIGRhdGVwaWNrZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIGRhdGVwaWNrZXItYm9yZGVyLWNvbG9yOlxuICogZGF0ZXBpY2tlci1ib3JkZXItc3R5bGU6XG4gKiBkYXRlcGlja2VyLWJvcmRlci13aWR0aDpcbiAqIGRhdGVwaWNrZXItYm9yZGVyLXJhZGl1czpcbiAqIGRhdGVwaWNrZXItc2hhZG93OlxuICogKi9cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIE5iRGF0ZXBpY2tlckRpcmVjdGl2ZTxEPiBpbXBsZW1lbnRzIE9uRGVzdHJveSwgQ29udHJvbFZhbHVlQWNjZXNzb3IsIFZhbGlkYXRvciB7XG4gICAgcHJvdGVjdGVkIGRvY3VtZW50OiBhbnk7XG4gICAgcHJvdGVjdGVkIGRhdGVwaWNrZXJBZGFwdGVyczogTmJEYXRlcGlja2VyQWRhcHRlcjxEPltdO1xuICAgIHByb3RlY3RlZCBob3N0UmVmOiBFbGVtZW50UmVmO1xuICAgIHByb3RlY3RlZCBkYXRlU2VydmljZTogTmJEYXRlU2VydmljZTxEPjtcbiAgICBwcm90ZWN0ZWQgY2hhbmdlRGV0ZWN0b3I6IENoYW5nZURldGVjdG9yUmVmO1xuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIGRhdGVwaWNrZXIgY29tcG9uZW50LlxuICAgICAqICovXG4gICAgc2V0IHNldFBpY2tlcihwaWNrZXI6IE5iRGF0ZXBpY2tlcjxEPik7XG4gICAgLyoqXG4gICAgICogRGF0ZXBpY2tlciBhZGFwdGVyLlxuICAgICAqICovXG4gICAgcHJvdGVjdGVkIGRhdGVwaWNrZXJBZGFwdGVyOiBOYkRhdGVwaWNrZXJBZGFwdGVyPEQ+O1xuICAgIC8qKlxuICAgICAqIERhdGVwaWNrZXIgaW5zdGFuY2UuXG4gICAgICogKi9cbiAgICBwcm90ZWN0ZWQgcGlja2VyOiBOYkRhdGVwaWNrZXI8RD47XG4gICAgcHJvdGVjdGVkIGRlc3Ryb3kkOiBTdWJqZWN0PHZvaWQ+O1xuICAgIHByb3RlY3RlZCBpc0RhdGVwaWNrZXJSZWFkeTogYm9vbGVhbjtcbiAgICBwcm90ZWN0ZWQgcXVldWU6IEQgfCB1bmRlZmluZWQ7XG4gICAgcHJvdGVjdGVkIG9uQ2hhbmdlOiAoRDogYW55KSA9PiB2b2lkO1xuICAgIHByb3RlY3RlZCBvblRvdWNoZWQ6ICgpID0+IHZvaWQ7XG4gICAgLyoqXG4gICAgICogRm9ybSBjb250cm9sIHZhbGlkYXRvcnMgd2lsbCBiZSBjYWxsZWQgaW4gdmFsaWRhdG9ycyBjb250ZXh0LCBzbywgd2UgbmVlZCB0byBiaW5kIHRoZW0uXG4gICAgICogKi9cbiAgICBwcm90ZWN0ZWQgdmFsaWRhdG9yOiBWYWxpZGF0b3JGbjtcbiAgICBjb25zdHJ1Y3Rvcihkb2N1bWVudDogYW55LCBkYXRlcGlja2VyQWRhcHRlcnM6IE5iRGF0ZXBpY2tlckFkYXB0ZXI8RD5bXSwgaG9zdFJlZjogRWxlbWVudFJlZiwgZGF0ZVNlcnZpY2U6IE5iRGF0ZVNlcnZpY2U8RD4sIGNoYW5nZURldGVjdG9yOiBDaGFuZ2VEZXRlY3RvclJlZik7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBodG1sIGlucHV0IGVsZW1lbnQuXG4gICAgICogKi9cbiAgICBnZXQgaW5wdXQoKTogSFRNTElucHV0RWxlbWVudDtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGhvc3QgaW5wdXQgdmFsdWUuXG4gICAgICogKi9cbiAgICBnZXQgaW5wdXRWYWx1ZSgpOiBzdHJpbmc7XG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBXcml0ZXMgdmFsdWUgaW4gcGlja2VyIGFuZCBodG1sIGlucHV0IGVsZW1lbnQuXG4gICAgICogKi9cbiAgICB3cml0ZVZhbHVlKHZhbHVlOiBEKTogdm9pZDtcbiAgICByZWdpc3Rlck9uQ2hhbmdlKGZuOiBhbnkpOiB2b2lkO1xuICAgIHJlZ2lzdGVyT25Ub3VjaGVkKGZuOiBhbnkpOiB2b2lkO1xuICAgIHNldERpc2FibGVkU3RhdGUoaXNEaXNhYmxlZDogYm9vbGVhbik6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogRm9ybSBjb250cm9sIHZhbGlkYXRpb24gYmFzZWQgb24gcGlja2VyIHZhbGlkYXRvciBjb25maWcuXG4gICAgICogKi9cbiAgICB2YWxpZGF0ZSgpOiBWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbDtcbiAgICAvKipcbiAgICAgKiBIaWRlcyBwaWNrZXIsIGZvY3VzZXMgdGhlIGlucHV0XG4gICAgICovXG4gICAgcHJvdGVjdGVkIGhpZGVQaWNrZXIoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZXMgdGhhdCB3ZSBjYW4gcGFyc2UgdmFsdWUgY29ycmVjdGx5LlxuICAgICAqICovXG4gICAgcHJvdGVjdGVkIHBhcnNlVmFsaWRhdG9yKCk6IFZhbGlkYXRpb25FcnJvcnMgfCBudWxsO1xuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlcyBwYXNzZWQgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIG1pbi5cbiAgICAgKiAqL1xuICAgIHByb3RlY3RlZCBtaW5WYWxpZGF0b3IoKTogVmFsaWRhdGlvbkVycm9ycyB8IG51bGw7XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGVzIHBhc3NlZCB2YWx1ZSBpcyBzbWFsbGVyIHRoYW4gbWF4LlxuICAgICAqICovXG4gICAgcHJvdGVjdGVkIG1heFZhbGlkYXRvcigpOiBWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbDtcbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZXMgcGFzc2VkIHZhbHVlIHNhdGlzZnkgdGhlIGZpbHRlci5cbiAgICAgKiAqL1xuICAgIHByb3RlY3RlZCBmaWx0ZXJWYWxpZGF0b3IoKTogVmFsaWRhdGlvbkVycm9ycyB8IG51bGw7XG4gICAgLyoqXG4gICAgICogQ2hvb3NlcyBkYXRlcGlja2VyIGFkYXB0ZXIgYmFzZWQgb24gcGFzc2VkIHBpY2tlciBjb21wb25lbnQuXG4gICAgICogKi9cbiAgICBwcm90ZWN0ZWQgY2hvb3NlRGF0ZXBpY2tlckFkYXB0ZXIoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBBdHRhY2hlcyBwaWNrZXIgdG8gdGhlIGhvc3QgaW5wdXQgZWxlbWVudCBhbmQgc3Vic2NyaWJlcyBvbiB2YWx1ZSBjaGFuZ2VzLlxuICAgICAqICovXG4gICAgcHJvdGVjdGVkIHNldHVwUGlja2VyKCk6IHZvaWQ7XG4gICAgcHJvdGVjdGVkIHdyaXRlUGlja2VyKHZhbHVlOiBEKTogdm9pZDtcbiAgICBwcm90ZWN0ZWQgd3JpdGVJbnB1dCh2YWx1ZTogRCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGVzIGlmIG5vIGRhdGVwaWNrZXIgYWRhcHRlciBwcm92aWRlZC5cbiAgICAgKiAqL1xuICAgIHByb3RlY3RlZCBub0RhdGVwaWNrZXJBZGFwdGVyUHJvdmlkZWQoKTogYm9vbGVhbjtcbiAgICBwcm90ZWN0ZWQgc3Vic2NyaWJlT25JbnB1dENoYW5nZSgpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFBhcnNlcyBpbnB1dCB2YWx1ZSBhbmQgd3JpdGUgaWYgaXQgaXNuJ3QgbnVsbC5cbiAgICAgKiAqL1xuICAgIHByb3RlY3RlZCBoYW5kbGVJbnB1dENoYW5nZSh2YWx1ZTogc3RyaW5nKTogdm9pZDtcbiAgICBwcm90ZWN0ZWQgcGFyc2VJbnB1dFZhbHVlKHZhbHVlOiBhbnkpOiBEIHwgbnVsbDtcbn1cbiJdfQ==