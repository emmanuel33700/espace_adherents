import { ComponentFactoryResolver, ComponentRef, OnChanges, ElementRef, EventEmitter, OnDestroy, Type, AfterViewInit, OnInit, SimpleChanges } from '@angular/core';
import { Observable, ReplaySubject, Subject } from 'rxjs';
import { NbOverlayRef } from '../cdk/overlay/mapping';
import { NbAdjustableConnectedPositionStrategy, NbPositionBuilderService } from '../cdk/overlay/overlay-position';
import { NbOverlayService } from '../cdk/overlay/overlay-service';
import { NbTriggerStrategy, NbTriggerStrategyBuilderService } from '../cdk/overlay/overlay-trigger';
import { NbDatepickerContainerComponent } from './datepicker-container.component';
import { NbCalendarRange, NbCalendarRangeComponent } from '../calendar/calendar-range.component';
import { NbCalendarComponent } from '../calendar/calendar.component';
import { NbCalendarCell, NbCalendarSize, NbCalendarViewMode, NbCalendarSizeValues, NbCalendarViewModeValues } from '../calendar-kit/model';
import { NbDateService } from '../calendar-kit/services/date.service';
import { NbDatepicker, NbPickerValidatorConfig } from './datepicker.directive';
import { NbBooleanInput } from '../helpers';
/**
 * The `NbBasePicker` component concentrates overlay manipulation logic.
 * */
import * as ɵngcc0 from '@angular/core';
export declare abstract class NbBasePicker<D, T, P> extends NbDatepicker<T> implements OnInit, OnChanges, AfterViewInit, OnDestroy {
    protected overlay: NbOverlayService;
    protected positionBuilder: NbPositionBuilderService;
    protected triggerStrategyBuilder: NbTriggerStrategyBuilderService;
    protected cfr: ComponentFactoryResolver;
    protected dateService: NbDateService<D>;
    protected dateServiceOptions: any;
    /**
     * Datepicker date format. Can be used only with date adapters (moment, date-fns) since native date
     * object doesn't support formatting.
     * */
    abstract format: string;
    /**
     * Defines if we should render previous and next months
     * in the current month view.
     * */
    abstract boundingMonth: boolean;
    /**
     * Defines starting view for calendar.
     * */
    abstract startView: NbCalendarViewMode;
    /**
     * Minimum available date for selection.
     * */
    abstract min: T;
    /**
     * Maximum available date for selection.
     * */
    abstract max: T;
    /**
     * Predicate that decides which cells will be disabled.
     * */
    abstract filter: (T: any) => boolean;
    /**
     * Custom day cell component. Have to implement `NbCalendarCell` interface.
     * */
    abstract dayCellComponent: Type<NbCalendarCell<D, T>>;
    /**
     * Custom month cell component. Have to implement `NbCalendarCell` interface.
     * */
    abstract monthCellComponent: Type<NbCalendarCell<D, T>>;
    /**
     * Custom year cell component. Have to implement `NbCalendarCell` interface.
     * */
    abstract yearCellComponent: Type<NbCalendarCell<D, T>>;
    /**
     * Size of the calendar and entire components.
     * Can be 'medium' which is default or 'large'.
     * */
    abstract size: NbCalendarSize;
    /**
     * Depending on this date a particular month is selected in the calendar
     */
    abstract visibleDate: D;
    /**
     * Hide picker when a date or a range is selected, `true` by default
     * @type {boolean}
     */
    abstract hideOnSelect: boolean;
    /**
     * Determines should we show calendar navigation or not.
     * @type {boolean}
     */
    abstract showNavigation: boolean;
    /**
     * Sets symbol used as a header for week numbers column
     * */
    abstract weekNumberSymbol: string;
    /**
     * Determines should we show week numbers column.
     * False by default.
     * */
    abstract showWeekNumber: boolean;
    /**
     * Calendar component class that has to be instantiated inside overlay.
     * */
    protected abstract pickerClass: Type<P>;
    /**
     * Overlay reference object.
     * */
    protected ref: NbOverlayRef;
    /**
     * Datepicker container that contains instantiated picker.
     * */
    protected container: ComponentRef<NbDatepickerContainerComponent>;
    /**
     * Positioning strategy used by overlay.
     * */
    protected positionStrategy: NbAdjustableConnectedPositionStrategy;
    /**
     * Trigger strategy used by overlay
     * */
    protected triggerStrategy: NbTriggerStrategy;
    /**
     * HTML input reference to which datepicker connected.
     * */
    protected hostRef: ElementRef;
    protected init$: ReplaySubject<void>;
    /**
     * Stream of picker changes. Required to be the subject because picker hides and shows and picker
     * change stream becomes recreated.
     * */
    protected onChange$: Subject<T>;
    /**
     * Reference to the picker instance itself.
     * */
    protected pickerRef: ComponentRef<any>;
    protected overlayOffset: number;
    protected destroy$: Subject<void>;
    /**
     * Queue contains the last value that was applied to the picker when it was hidden.
     * This value will be passed to the picker as soon as it shown.
     * */
    protected queue: T | undefined;
    protected blur$: Subject<void>;
    protected constructor(overlay: NbOverlayService, positionBuilder: NbPositionBuilderService, triggerStrategyBuilder: NbTriggerStrategyBuilderService, cfr: ComponentFactoryResolver, dateService: NbDateService<D>, dateServiceOptions: any);
    /**
     * Returns picker instance.
     * */
    get picker(): any;
    /**
     * Stream of picker value changes.
     * */
    get valueChange(): Observable<T>;
    get isShown(): boolean;
    get init(): Observable<void>;
    /**
     * Emits when datepicker looses focus.
     */
    get blur(): Observable<void>;
    protected abstract get pickerValueChange(): Observable<T>;
    ngOnInit(): void;
    ngOnChanges(changes: SimpleChanges): void;
    ngAfterViewInit(): void;
    ngOnDestroy(): void;
    /**
     * Datepicker knows nothing about host html input element.
     * So, attach method attaches datepicker to the host input element.
     * */
    attach(hostRef: ElementRef): void;
    getValidatorConfig(): NbPickerValidatorConfig<T>;
    show(): void;
    shouldHide(): boolean;
    hide(): void;
    protected abstract writeQueue(): any;
    protected createOverlay(): void;
    protected openDatepicker(): void;
    protected createPositionStrategy(): NbAdjustableConnectedPositionStrategy;
    protected subscribeOnPositionChange(): void;
    protected createTriggerStrategy(): NbTriggerStrategy;
    protected subscribeOnTriggers(): void;
    protected instantiatePicker(): void;
    /**
     * Subscribes on picker value changes and emit data through this.onChange$ subject.
     * */
    protected subscribeOnValueChange(): void;
    protected patchWithInputs(): void;
    protected checkFormat(): void;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<NbBasePicker<any, any, any>, never>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<NbBasePicker<any, any, any>, never, never, {}, {}, never>;
}
export declare class NbBasePickerComponent<D, T, P> extends NbBasePicker<D, T, P> {
    /**
     * Datepicker date format. Can be used only with date adapters (moment, date-fns) since native date
     * object doesn't support formatting.
     * */
    format: string;
    /**
     * Defines if we should render previous and next months
     * in the current month view.
     * */
    boundingMonth: boolean;
    /**
     * Defines starting view for calendar.
     * */
    startView: NbCalendarViewMode;
    static ngAcceptInputType_startView: NbCalendarViewModeValues;
    /**
     * Minimum available date for selection.
     * */
    min: T;
    /**
     * Maximum available date for selection.
     * */
    max: T;
    /**
     * Predicate that decides which cells will be disabled.
     * */
    filter: (T: any) => boolean;
    /**
     * Custom day cell component. Have to implement `NbCalendarCell` interface.
     * */
    dayCellComponent: Type<NbCalendarCell<D, T>>;
    /**
     * Custom month cell component. Have to implement `NbCalendarCell` interface.
     * */
    monthCellComponent: Type<NbCalendarCell<D, T>>;
    /**
     * Custom year cell component. Have to implement `NbCalendarCell` interface.
     * */
    yearCellComponent: Type<NbCalendarCell<D, T>>;
    /**
     * Size of the calendar and entire components.
     * Can be 'medium' which is default or 'large'.
     * */
    size: NbCalendarSize;
    static ngAcceptInputType_size: NbCalendarSizeValues;
    /**
     * Depending on this date a particular month is selected in the calendar
     */
    visibleDate: D;
    /**
     * Hide picker when a date or a range is selected, `true` by default
     * @type {boolean}
     */
    hideOnSelect: boolean;
    /**
     * Determines should we show calendars navigation or not.
     * @type {boolean}
     */
    showNavigation: boolean;
    /**
     * Sets symbol used as a header for week numbers column
     * */
    weekNumberSymbol: string;
    /**
     * Determines should we show week numbers column.
     * False by default.
     * */
    get showWeekNumber(): boolean;
    set showWeekNumber(value: boolean);
    protected _showWeekNumber: boolean;
    static ngAcceptInputType_showWeekNumber: NbBooleanInput;
    constructor(document: any, positionBuilder: NbPositionBuilderService, triggerStrategyBuilder: NbTriggerStrategyBuilderService, overlay: NbOverlayService, cfr: ComponentFactoryResolver, dateService: NbDateService<D>, dateServiceOptions: any);
    protected pickerClass: Type<P>;
    protected get pickerValueChange(): Observable<T>;
    get value(): T;
    set value(value: T);
    protected writeQueue(): void;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<NbBasePickerComponent<any, any, any>, [null, null, null, null, null, null, { optional: true; }]>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<NbBasePickerComponent<any, any, any>, "ng-component", never, { "boundingMonth": "boundingMonth"; "startView": "startView"; "size": "size"; "hideOnSelect": "hideOnSelect"; "showNavigation": "showNavigation"; "weekNumberSymbol": "weekNumberSymbol"; "showWeekNumber": "showWeekNumber"; "format": "format"; "min": "min"; "max": "max"; "filter": "filter"; "dayCellComponent": "dayCellComponent"; "monthCellComponent": "monthCellComponent"; "yearCellComponent": "yearCellComponent"; "visibleDate": "visibleDate"; }, {}, never, never>;
}
/**
 * The DatePicker components itself.
 * Provides a proxy to `NbCalendar` options as well as custom picker options.
 */
export declare class NbDatepickerComponent<D> extends NbBasePickerComponent<D, D, NbCalendarComponent<D>> {
    protected pickerClass: Type<NbCalendarComponent<D>>;
    /**
     * Date which will be rendered as selected.
     * */
    set date(date: D);
    /**
     * Emits date when selected.
     * */
    get dateChange(): EventEmitter<D>;
    get value(): D;
    set value(date: D);
    protected get pickerValueChange(): Observable<D>;
    protected writeQueue(): void;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<NbDatepickerComponent<any>, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<NbDatepickerComponent<any>, "nb-datepicker", never, { "date": "date"; }, { "dateChange": "dateChange"; }, never, never>;
}
/**
 * The RangeDatePicker components itself.
 * Provides a proxy to `NbCalendarRange` options as well as custom picker options.
 */
export declare class NbRangepickerComponent<D> extends NbBasePickerComponent<D, NbCalendarRange<D>, NbCalendarRangeComponent<D>> {
    protected pickerClass: Type<NbCalendarRangeComponent<D>>;
    /**
     * Range which will be rendered as selected.
     * */
    set range(range: NbCalendarRange<D>);
    /**
     * Emits range when start selected and emits again when end selected.
     * */
    get rangeChange(): EventEmitter<NbCalendarRange<D>>;
    get value(): NbCalendarRange<D>;
    set value(range: NbCalendarRange<D>);
    protected get pickerValueChange(): Observable<NbCalendarRange<D>>;
    shouldHide(): boolean;
    protected writeQueue(): void;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<NbRangepickerComponent<any>, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<NbRangepickerComponent<any>, "nb-rangepicker", never, { "range": "range"; }, { "rangeChange": "rangeChange"; }, never, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZXBpY2tlci5jb21wb25lbnQuZC50cyIsInNvdXJjZXMiOlsiZGF0ZXBpY2tlci5jb21wb25lbnQuZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE4SkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQStFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBbUJBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBb0JBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLCBDb21wb25lbnRSZWYsIE9uQ2hhbmdlcywgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBPbkRlc3Ryb3ksIFR5cGUsIEFmdGVyVmlld0luaXQsIE9uSW5pdCwgU2ltcGxlQ2hhbmdlcyB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgUmVwbGF5U3ViamVjdCwgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgTmJPdmVybGF5UmVmIH0gZnJvbSAnLi4vY2RrL292ZXJsYXkvbWFwcGluZyc7XG5pbXBvcnQgeyBOYkFkanVzdGFibGVDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5LCBOYlBvc2l0aW9uQnVpbGRlclNlcnZpY2UgfSBmcm9tICcuLi9jZGsvb3ZlcmxheS9vdmVybGF5LXBvc2l0aW9uJztcbmltcG9ydCB7IE5iT3ZlcmxheVNlcnZpY2UgfSBmcm9tICcuLi9jZGsvb3ZlcmxheS9vdmVybGF5LXNlcnZpY2UnO1xuaW1wb3J0IHsgTmJUcmlnZ2VyU3RyYXRlZ3ksIE5iVHJpZ2dlclN0cmF0ZWd5QnVpbGRlclNlcnZpY2UgfSBmcm9tICcuLi9jZGsvb3ZlcmxheS9vdmVybGF5LXRyaWdnZXInO1xuaW1wb3J0IHsgTmJEYXRlcGlja2VyQ29udGFpbmVyQ29tcG9uZW50IH0gZnJvbSAnLi9kYXRlcGlja2VyLWNvbnRhaW5lci5jb21wb25lbnQnO1xuaW1wb3J0IHsgTmJDYWxlbmRhclJhbmdlLCBOYkNhbGVuZGFyUmFuZ2VDb21wb25lbnQgfSBmcm9tICcuLi9jYWxlbmRhci9jYWxlbmRhci1yYW5nZS5jb21wb25lbnQnO1xuaW1wb3J0IHsgTmJDYWxlbmRhckNvbXBvbmVudCB9IGZyb20gJy4uL2NhbGVuZGFyL2NhbGVuZGFyLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBOYkNhbGVuZGFyQ2VsbCwgTmJDYWxlbmRhclNpemUsIE5iQ2FsZW5kYXJWaWV3TW9kZSwgTmJDYWxlbmRhclNpemVWYWx1ZXMsIE5iQ2FsZW5kYXJWaWV3TW9kZVZhbHVlcyB9IGZyb20gJy4uL2NhbGVuZGFyLWtpdC9tb2RlbCc7XG5pbXBvcnQgeyBOYkRhdGVTZXJ2aWNlIH0gZnJvbSAnLi4vY2FsZW5kYXIta2l0L3NlcnZpY2VzL2RhdGUuc2VydmljZSc7XG5pbXBvcnQgeyBOYkRhdGVwaWNrZXIsIE5iUGlja2VyVmFsaWRhdG9yQ29uZmlnIH0gZnJvbSAnLi9kYXRlcGlja2VyLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBOYkJvb2xlYW5JbnB1dCB9IGZyb20gJy4uL2hlbHBlcnMnO1xuLyoqXG4gKiBUaGUgYE5iQmFzZVBpY2tlcmAgY29tcG9uZW50IGNvbmNlbnRyYXRlcyBvdmVybGF5IG1hbmlwdWxhdGlvbiBsb2dpYy5cbiAqICovXG5leHBvcnQgZGVjbGFyZSBhYnN0cmFjdCBjbGFzcyBOYkJhc2VQaWNrZXI8RCwgVCwgUD4gZXh0ZW5kcyBOYkRhdGVwaWNrZXI8VD4gaW1wbGVtZW50cyBPbkluaXQsIE9uQ2hhbmdlcywgQWZ0ZXJWaWV3SW5pdCwgT25EZXN0cm95IHtcbiAgICBwcm90ZWN0ZWQgb3ZlcmxheTogTmJPdmVybGF5U2VydmljZTtcbiAgICBwcm90ZWN0ZWQgcG9zaXRpb25CdWlsZGVyOiBOYlBvc2l0aW9uQnVpbGRlclNlcnZpY2U7XG4gICAgcHJvdGVjdGVkIHRyaWdnZXJTdHJhdGVneUJ1aWxkZXI6IE5iVHJpZ2dlclN0cmF0ZWd5QnVpbGRlclNlcnZpY2U7XG4gICAgcHJvdGVjdGVkIGNmcjogQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyO1xuICAgIHByb3RlY3RlZCBkYXRlU2VydmljZTogTmJEYXRlU2VydmljZTxEPjtcbiAgICBwcm90ZWN0ZWQgZGF0ZVNlcnZpY2VPcHRpb25zOiBhbnk7XG4gICAgLyoqXG4gICAgICogRGF0ZXBpY2tlciBkYXRlIGZvcm1hdC4gQ2FuIGJlIHVzZWQgb25seSB3aXRoIGRhdGUgYWRhcHRlcnMgKG1vbWVudCwgZGF0ZS1mbnMpIHNpbmNlIG5hdGl2ZSBkYXRlXG4gICAgICogb2JqZWN0IGRvZXNuJ3Qgc3VwcG9ydCBmb3JtYXR0aW5nLlxuICAgICAqICovXG4gICAgYWJzdHJhY3QgZm9ybWF0OiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogRGVmaW5lcyBpZiB3ZSBzaG91bGQgcmVuZGVyIHByZXZpb3VzIGFuZCBuZXh0IG1vbnRoc1xuICAgICAqIGluIHRoZSBjdXJyZW50IG1vbnRoIHZpZXcuXG4gICAgICogKi9cbiAgICBhYnN0cmFjdCBib3VuZGluZ01vbnRoOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIERlZmluZXMgc3RhcnRpbmcgdmlldyBmb3IgY2FsZW5kYXIuXG4gICAgICogKi9cbiAgICBhYnN0cmFjdCBzdGFydFZpZXc6IE5iQ2FsZW5kYXJWaWV3TW9kZTtcbiAgICAvKipcbiAgICAgKiBNaW5pbXVtIGF2YWlsYWJsZSBkYXRlIGZvciBzZWxlY3Rpb24uXG4gICAgICogKi9cbiAgICBhYnN0cmFjdCBtaW46IFQ7XG4gICAgLyoqXG4gICAgICogTWF4aW11bSBhdmFpbGFibGUgZGF0ZSBmb3Igc2VsZWN0aW9uLlxuICAgICAqICovXG4gICAgYWJzdHJhY3QgbWF4OiBUO1xuICAgIC8qKlxuICAgICAqIFByZWRpY2F0ZSB0aGF0IGRlY2lkZXMgd2hpY2ggY2VsbHMgd2lsbCBiZSBkaXNhYmxlZC5cbiAgICAgKiAqL1xuICAgIGFic3RyYWN0IGZpbHRlcjogKFQ6IGFueSkgPT4gYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBDdXN0b20gZGF5IGNlbGwgY29tcG9uZW50LiBIYXZlIHRvIGltcGxlbWVudCBgTmJDYWxlbmRhckNlbGxgIGludGVyZmFjZS5cbiAgICAgKiAqL1xuICAgIGFic3RyYWN0IGRheUNlbGxDb21wb25lbnQ6IFR5cGU8TmJDYWxlbmRhckNlbGw8RCwgVD4+O1xuICAgIC8qKlxuICAgICAqIEN1c3RvbSBtb250aCBjZWxsIGNvbXBvbmVudC4gSGF2ZSB0byBpbXBsZW1lbnQgYE5iQ2FsZW5kYXJDZWxsYCBpbnRlcmZhY2UuXG4gICAgICogKi9cbiAgICBhYnN0cmFjdCBtb250aENlbGxDb21wb25lbnQ6IFR5cGU8TmJDYWxlbmRhckNlbGw8RCwgVD4+O1xuICAgIC8qKlxuICAgICAqIEN1c3RvbSB5ZWFyIGNlbGwgY29tcG9uZW50LiBIYXZlIHRvIGltcGxlbWVudCBgTmJDYWxlbmRhckNlbGxgIGludGVyZmFjZS5cbiAgICAgKiAqL1xuICAgIGFic3RyYWN0IHllYXJDZWxsQ29tcG9uZW50OiBUeXBlPE5iQ2FsZW5kYXJDZWxsPEQsIFQ+PjtcbiAgICAvKipcbiAgICAgKiBTaXplIG9mIHRoZSBjYWxlbmRhciBhbmQgZW50aXJlIGNvbXBvbmVudHMuXG4gICAgICogQ2FuIGJlICdtZWRpdW0nIHdoaWNoIGlzIGRlZmF1bHQgb3IgJ2xhcmdlJy5cbiAgICAgKiAqL1xuICAgIGFic3RyYWN0IHNpemU6IE5iQ2FsZW5kYXJTaXplO1xuICAgIC8qKlxuICAgICAqIERlcGVuZGluZyBvbiB0aGlzIGRhdGUgYSBwYXJ0aWN1bGFyIG1vbnRoIGlzIHNlbGVjdGVkIGluIHRoZSBjYWxlbmRhclxuICAgICAqL1xuICAgIGFic3RyYWN0IHZpc2libGVEYXRlOiBEO1xuICAgIC8qKlxuICAgICAqIEhpZGUgcGlja2VyIHdoZW4gYSBkYXRlIG9yIGEgcmFuZ2UgaXMgc2VsZWN0ZWQsIGB0cnVlYCBieSBkZWZhdWx0XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgYWJzdHJhY3QgaGlkZU9uU2VsZWN0OiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgc2hvdWxkIHdlIHNob3cgY2FsZW5kYXIgbmF2aWdhdGlvbiBvciBub3QuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgYWJzdHJhY3Qgc2hvd05hdmlnYXRpb246IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogU2V0cyBzeW1ib2wgdXNlZCBhcyBhIGhlYWRlciBmb3Igd2VlayBudW1iZXJzIGNvbHVtblxuICAgICAqICovXG4gICAgYWJzdHJhY3Qgd2Vla051bWJlclN5bWJvbDogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgc2hvdWxkIHdlIHNob3cgd2VlayBudW1iZXJzIGNvbHVtbi5cbiAgICAgKiBGYWxzZSBieSBkZWZhdWx0LlxuICAgICAqICovXG4gICAgYWJzdHJhY3Qgc2hvd1dlZWtOdW1iZXI6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogQ2FsZW5kYXIgY29tcG9uZW50IGNsYXNzIHRoYXQgaGFzIHRvIGJlIGluc3RhbnRpYXRlZCBpbnNpZGUgb3ZlcmxheS5cbiAgICAgKiAqL1xuICAgIHByb3RlY3RlZCBhYnN0cmFjdCBwaWNrZXJDbGFzczogVHlwZTxQPjtcbiAgICAvKipcbiAgICAgKiBPdmVybGF5IHJlZmVyZW5jZSBvYmplY3QuXG4gICAgICogKi9cbiAgICBwcm90ZWN0ZWQgcmVmOiBOYk92ZXJsYXlSZWY7XG4gICAgLyoqXG4gICAgICogRGF0ZXBpY2tlciBjb250YWluZXIgdGhhdCBjb250YWlucyBpbnN0YW50aWF0ZWQgcGlja2VyLlxuICAgICAqICovXG4gICAgcHJvdGVjdGVkIGNvbnRhaW5lcjogQ29tcG9uZW50UmVmPE5iRGF0ZXBpY2tlckNvbnRhaW5lckNvbXBvbmVudD47XG4gICAgLyoqXG4gICAgICogUG9zaXRpb25pbmcgc3RyYXRlZ3kgdXNlZCBieSBvdmVybGF5LlxuICAgICAqICovXG4gICAgcHJvdGVjdGVkIHBvc2l0aW9uU3RyYXRlZ3k6IE5iQWRqdXN0YWJsZUNvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3k7XG4gICAgLyoqXG4gICAgICogVHJpZ2dlciBzdHJhdGVneSB1c2VkIGJ5IG92ZXJsYXlcbiAgICAgKiAqL1xuICAgIHByb3RlY3RlZCB0cmlnZ2VyU3RyYXRlZ3k6IE5iVHJpZ2dlclN0cmF0ZWd5O1xuICAgIC8qKlxuICAgICAqIEhUTUwgaW5wdXQgcmVmZXJlbmNlIHRvIHdoaWNoIGRhdGVwaWNrZXIgY29ubmVjdGVkLlxuICAgICAqICovXG4gICAgcHJvdGVjdGVkIGhvc3RSZWY6IEVsZW1lbnRSZWY7XG4gICAgcHJvdGVjdGVkIGluaXQkOiBSZXBsYXlTdWJqZWN0PHZvaWQ+O1xuICAgIC8qKlxuICAgICAqIFN0cmVhbSBvZiBwaWNrZXIgY2hhbmdlcy4gUmVxdWlyZWQgdG8gYmUgdGhlIHN1YmplY3QgYmVjYXVzZSBwaWNrZXIgaGlkZXMgYW5kIHNob3dzIGFuZCBwaWNrZXJcbiAgICAgKiBjaGFuZ2Ugc3RyZWFtIGJlY29tZXMgcmVjcmVhdGVkLlxuICAgICAqICovXG4gICAgcHJvdGVjdGVkIG9uQ2hhbmdlJDogU3ViamVjdDxUPjtcbiAgICAvKipcbiAgICAgKiBSZWZlcmVuY2UgdG8gdGhlIHBpY2tlciBpbnN0YW5jZSBpdHNlbGYuXG4gICAgICogKi9cbiAgICBwcm90ZWN0ZWQgcGlja2VyUmVmOiBDb21wb25lbnRSZWY8YW55PjtcbiAgICBwcm90ZWN0ZWQgb3ZlcmxheU9mZnNldDogbnVtYmVyO1xuICAgIHByb3RlY3RlZCBkZXN0cm95JDogU3ViamVjdDx2b2lkPjtcbiAgICAvKipcbiAgICAgKiBRdWV1ZSBjb250YWlucyB0aGUgbGFzdCB2YWx1ZSB0aGF0IHdhcyBhcHBsaWVkIHRvIHRoZSBwaWNrZXIgd2hlbiBpdCB3YXMgaGlkZGVuLlxuICAgICAqIFRoaXMgdmFsdWUgd2lsbCBiZSBwYXNzZWQgdG8gdGhlIHBpY2tlciBhcyBzb29uIGFzIGl0IHNob3duLlxuICAgICAqICovXG4gICAgcHJvdGVjdGVkIHF1ZXVlOiBUIHwgdW5kZWZpbmVkO1xuICAgIHByb3RlY3RlZCBibHVyJDogU3ViamVjdDx2b2lkPjtcbiAgICBwcm90ZWN0ZWQgY29uc3RydWN0b3Iob3ZlcmxheTogTmJPdmVybGF5U2VydmljZSwgcG9zaXRpb25CdWlsZGVyOiBOYlBvc2l0aW9uQnVpbGRlclNlcnZpY2UsIHRyaWdnZXJTdHJhdGVneUJ1aWxkZXI6IE5iVHJpZ2dlclN0cmF0ZWd5QnVpbGRlclNlcnZpY2UsIGNmcjogQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLCBkYXRlU2VydmljZTogTmJEYXRlU2VydmljZTxEPiwgZGF0ZVNlcnZpY2VPcHRpb25zOiBhbnkpO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgcGlja2VyIGluc3RhbmNlLlxuICAgICAqICovXG4gICAgZ2V0IHBpY2tlcigpOiBhbnk7XG4gICAgLyoqXG4gICAgICogU3RyZWFtIG9mIHBpY2tlciB2YWx1ZSBjaGFuZ2VzLlxuICAgICAqICovXG4gICAgZ2V0IHZhbHVlQ2hhbmdlKCk6IE9ic2VydmFibGU8VD47XG4gICAgZ2V0IGlzU2hvd24oKTogYm9vbGVhbjtcbiAgICBnZXQgaW5pdCgpOiBPYnNlcnZhYmxlPHZvaWQ+O1xuICAgIC8qKlxuICAgICAqIEVtaXRzIHdoZW4gZGF0ZXBpY2tlciBsb29zZXMgZm9jdXMuXG4gICAgICovXG4gICAgZ2V0IGJsdXIoKTogT2JzZXJ2YWJsZTx2b2lkPjtcbiAgICBwcm90ZWN0ZWQgYWJzdHJhY3QgZ2V0IHBpY2tlclZhbHVlQ2hhbmdlKCk6IE9ic2VydmFibGU8VD47XG4gICAgbmdPbkluaXQoKTogdm9pZDtcbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZDtcbiAgICBuZ0FmdGVyVmlld0luaXQoKTogdm9pZDtcbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIERhdGVwaWNrZXIga25vd3Mgbm90aGluZyBhYm91dCBob3N0IGh0bWwgaW5wdXQgZWxlbWVudC5cbiAgICAgKiBTbywgYXR0YWNoIG1ldGhvZCBhdHRhY2hlcyBkYXRlcGlja2VyIHRvIHRoZSBob3N0IGlucHV0IGVsZW1lbnQuXG4gICAgICogKi9cbiAgICBhdHRhY2goaG9zdFJlZjogRWxlbWVudFJlZik6IHZvaWQ7XG4gICAgZ2V0VmFsaWRhdG9yQ29uZmlnKCk6IE5iUGlja2VyVmFsaWRhdG9yQ29uZmlnPFQ+O1xuICAgIHNob3coKTogdm9pZDtcbiAgICBzaG91bGRIaWRlKCk6IGJvb2xlYW47XG4gICAgaGlkZSgpOiB2b2lkO1xuICAgIHByb3RlY3RlZCBhYnN0cmFjdCB3cml0ZVF1ZXVlKCk6IGFueTtcbiAgICBwcm90ZWN0ZWQgY3JlYXRlT3ZlcmxheSgpOiB2b2lkO1xuICAgIHByb3RlY3RlZCBvcGVuRGF0ZXBpY2tlcigpOiB2b2lkO1xuICAgIHByb3RlY3RlZCBjcmVhdGVQb3NpdGlvblN0cmF0ZWd5KCk6IE5iQWRqdXN0YWJsZUNvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3k7XG4gICAgcHJvdGVjdGVkIHN1YnNjcmliZU9uUG9zaXRpb25DaGFuZ2UoKTogdm9pZDtcbiAgICBwcm90ZWN0ZWQgY3JlYXRlVHJpZ2dlclN0cmF0ZWd5KCk6IE5iVHJpZ2dlclN0cmF0ZWd5O1xuICAgIHByb3RlY3RlZCBzdWJzY3JpYmVPblRyaWdnZXJzKCk6IHZvaWQ7XG4gICAgcHJvdGVjdGVkIGluc3RhbnRpYXRlUGlja2VyKCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogU3Vic2NyaWJlcyBvbiBwaWNrZXIgdmFsdWUgY2hhbmdlcyBhbmQgZW1pdCBkYXRhIHRocm91Z2ggdGhpcy5vbkNoYW5nZSQgc3ViamVjdC5cbiAgICAgKiAqL1xuICAgIHByb3RlY3RlZCBzdWJzY3JpYmVPblZhbHVlQ2hhbmdlKCk6IHZvaWQ7XG4gICAgcHJvdGVjdGVkIHBhdGNoV2l0aElucHV0cygpOiB2b2lkO1xuICAgIHByb3RlY3RlZCBjaGVja0Zvcm1hdCgpOiB2b2lkO1xufVxuZXhwb3J0IGRlY2xhcmUgY2xhc3MgTmJCYXNlUGlja2VyQ29tcG9uZW50PEQsIFQsIFA+IGV4dGVuZHMgTmJCYXNlUGlja2VyPEQsIFQsIFA+IHtcbiAgICAvKipcbiAgICAgKiBEYXRlcGlja2VyIGRhdGUgZm9ybWF0LiBDYW4gYmUgdXNlZCBvbmx5IHdpdGggZGF0ZSBhZGFwdGVycyAobW9tZW50LCBkYXRlLWZucykgc2luY2UgbmF0aXZlIGRhdGVcbiAgICAgKiBvYmplY3QgZG9lc24ndCBzdXBwb3J0IGZvcm1hdHRpbmcuXG4gICAgICogKi9cbiAgICBmb3JtYXQ6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIGlmIHdlIHNob3VsZCByZW5kZXIgcHJldmlvdXMgYW5kIG5leHQgbW9udGhzXG4gICAgICogaW4gdGhlIGN1cnJlbnQgbW9udGggdmlldy5cbiAgICAgKiAqL1xuICAgIGJvdW5kaW5nTW9udGg6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogRGVmaW5lcyBzdGFydGluZyB2aWV3IGZvciBjYWxlbmRhci5cbiAgICAgKiAqL1xuICAgIHN0YXJ0VmlldzogTmJDYWxlbmRhclZpZXdNb2RlO1xuICAgIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV9zdGFydFZpZXc6IE5iQ2FsZW5kYXJWaWV3TW9kZVZhbHVlcztcbiAgICAvKipcbiAgICAgKiBNaW5pbXVtIGF2YWlsYWJsZSBkYXRlIGZvciBzZWxlY3Rpb24uXG4gICAgICogKi9cbiAgICBtaW46IFQ7XG4gICAgLyoqXG4gICAgICogTWF4aW11bSBhdmFpbGFibGUgZGF0ZSBmb3Igc2VsZWN0aW9uLlxuICAgICAqICovXG4gICAgbWF4OiBUO1xuICAgIC8qKlxuICAgICAqIFByZWRpY2F0ZSB0aGF0IGRlY2lkZXMgd2hpY2ggY2VsbHMgd2lsbCBiZSBkaXNhYmxlZC5cbiAgICAgKiAqL1xuICAgIGZpbHRlcjogKFQ6IGFueSkgPT4gYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBDdXN0b20gZGF5IGNlbGwgY29tcG9uZW50LiBIYXZlIHRvIGltcGxlbWVudCBgTmJDYWxlbmRhckNlbGxgIGludGVyZmFjZS5cbiAgICAgKiAqL1xuICAgIGRheUNlbGxDb21wb25lbnQ6IFR5cGU8TmJDYWxlbmRhckNlbGw8RCwgVD4+O1xuICAgIC8qKlxuICAgICAqIEN1c3RvbSBtb250aCBjZWxsIGNvbXBvbmVudC4gSGF2ZSB0byBpbXBsZW1lbnQgYE5iQ2FsZW5kYXJDZWxsYCBpbnRlcmZhY2UuXG4gICAgICogKi9cbiAgICBtb250aENlbGxDb21wb25lbnQ6IFR5cGU8TmJDYWxlbmRhckNlbGw8RCwgVD4+O1xuICAgIC8qKlxuICAgICAqIEN1c3RvbSB5ZWFyIGNlbGwgY29tcG9uZW50LiBIYXZlIHRvIGltcGxlbWVudCBgTmJDYWxlbmRhckNlbGxgIGludGVyZmFjZS5cbiAgICAgKiAqL1xuICAgIHllYXJDZWxsQ29tcG9uZW50OiBUeXBlPE5iQ2FsZW5kYXJDZWxsPEQsIFQ+PjtcbiAgICAvKipcbiAgICAgKiBTaXplIG9mIHRoZSBjYWxlbmRhciBhbmQgZW50aXJlIGNvbXBvbmVudHMuXG4gICAgICogQ2FuIGJlICdtZWRpdW0nIHdoaWNoIGlzIGRlZmF1bHQgb3IgJ2xhcmdlJy5cbiAgICAgKiAqL1xuICAgIHNpemU6IE5iQ2FsZW5kYXJTaXplO1xuICAgIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV9zaXplOiBOYkNhbGVuZGFyU2l6ZVZhbHVlcztcbiAgICAvKipcbiAgICAgKiBEZXBlbmRpbmcgb24gdGhpcyBkYXRlIGEgcGFydGljdWxhciBtb250aCBpcyBzZWxlY3RlZCBpbiB0aGUgY2FsZW5kYXJcbiAgICAgKi9cbiAgICB2aXNpYmxlRGF0ZTogRDtcbiAgICAvKipcbiAgICAgKiBIaWRlIHBpY2tlciB3aGVuIGEgZGF0ZSBvciBhIHJhbmdlIGlzIHNlbGVjdGVkLCBgdHJ1ZWAgYnkgZGVmYXVsdFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIGhpZGVPblNlbGVjdDogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHNob3VsZCB3ZSBzaG93IGNhbGVuZGFycyBuYXZpZ2F0aW9uIG9yIG5vdC5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBzaG93TmF2aWdhdGlvbjogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBTZXRzIHN5bWJvbCB1c2VkIGFzIGEgaGVhZGVyIGZvciB3ZWVrIG51bWJlcnMgY29sdW1uXG4gICAgICogKi9cbiAgICB3ZWVrTnVtYmVyU3ltYm9sOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBzaG91bGQgd2Ugc2hvdyB3ZWVrIG51bWJlcnMgY29sdW1uLlxuICAgICAqIEZhbHNlIGJ5IGRlZmF1bHQuXG4gICAgICogKi9cbiAgICBnZXQgc2hvd1dlZWtOdW1iZXIoKTogYm9vbGVhbjtcbiAgICBzZXQgc2hvd1dlZWtOdW1iZXIodmFsdWU6IGJvb2xlYW4pO1xuICAgIHByb3RlY3RlZCBfc2hvd1dlZWtOdW1iZXI6IGJvb2xlYW47XG4gICAgc3RhdGljIG5nQWNjZXB0SW5wdXRUeXBlX3Nob3dXZWVrTnVtYmVyOiBOYkJvb2xlYW5JbnB1dDtcbiAgICBjb25zdHJ1Y3Rvcihkb2N1bWVudDogYW55LCBwb3NpdGlvbkJ1aWxkZXI6IE5iUG9zaXRpb25CdWlsZGVyU2VydmljZSwgdHJpZ2dlclN0cmF0ZWd5QnVpbGRlcjogTmJUcmlnZ2VyU3RyYXRlZ3lCdWlsZGVyU2VydmljZSwgb3ZlcmxheTogTmJPdmVybGF5U2VydmljZSwgY2ZyOiBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsIGRhdGVTZXJ2aWNlOiBOYkRhdGVTZXJ2aWNlPEQ+LCBkYXRlU2VydmljZU9wdGlvbnM6IGFueSk7XG4gICAgcHJvdGVjdGVkIHBpY2tlckNsYXNzOiBUeXBlPFA+O1xuICAgIHByb3RlY3RlZCBnZXQgcGlja2VyVmFsdWVDaGFuZ2UoKTogT2JzZXJ2YWJsZTxUPjtcbiAgICBnZXQgdmFsdWUoKTogVDtcbiAgICBzZXQgdmFsdWUodmFsdWU6IFQpO1xuICAgIHByb3RlY3RlZCB3cml0ZVF1ZXVlKCk6IHZvaWQ7XG59XG4vKipcbiAqIFRoZSBEYXRlUGlja2VyIGNvbXBvbmVudHMgaXRzZWxmLlxuICogUHJvdmlkZXMgYSBwcm94eSB0byBgTmJDYWxlbmRhcmAgb3B0aW9ucyBhcyB3ZWxsIGFzIGN1c3RvbSBwaWNrZXIgb3B0aW9ucy5cbiAqL1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgTmJEYXRlcGlja2VyQ29tcG9uZW50PEQ+IGV4dGVuZHMgTmJCYXNlUGlja2VyQ29tcG9uZW50PEQsIEQsIE5iQ2FsZW5kYXJDb21wb25lbnQ8RD4+IHtcbiAgICBwcm90ZWN0ZWQgcGlja2VyQ2xhc3M6IFR5cGU8TmJDYWxlbmRhckNvbXBvbmVudDxEPj47XG4gICAgLyoqXG4gICAgICogRGF0ZSB3aGljaCB3aWxsIGJlIHJlbmRlcmVkIGFzIHNlbGVjdGVkLlxuICAgICAqICovXG4gICAgc2V0IGRhdGUoZGF0ZTogRCk7XG4gICAgLyoqXG4gICAgICogRW1pdHMgZGF0ZSB3aGVuIHNlbGVjdGVkLlxuICAgICAqICovXG4gICAgZ2V0IGRhdGVDaGFuZ2UoKTogRXZlbnRFbWl0dGVyPEQ+O1xuICAgIGdldCB2YWx1ZSgpOiBEO1xuICAgIHNldCB2YWx1ZShkYXRlOiBEKTtcbiAgICBwcm90ZWN0ZWQgZ2V0IHBpY2tlclZhbHVlQ2hhbmdlKCk6IE9ic2VydmFibGU8RD47XG4gICAgcHJvdGVjdGVkIHdyaXRlUXVldWUoKTogdm9pZDtcbn1cbi8qKlxuICogVGhlIFJhbmdlRGF0ZVBpY2tlciBjb21wb25lbnRzIGl0c2VsZi5cbiAqIFByb3ZpZGVzIGEgcHJveHkgdG8gYE5iQ2FsZW5kYXJSYW5nZWAgb3B0aW9ucyBhcyB3ZWxsIGFzIGN1c3RvbSBwaWNrZXIgb3B0aW9ucy5cbiAqL1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgTmJSYW5nZXBpY2tlckNvbXBvbmVudDxEPiBleHRlbmRzIE5iQmFzZVBpY2tlckNvbXBvbmVudDxELCBOYkNhbGVuZGFyUmFuZ2U8RD4sIE5iQ2FsZW5kYXJSYW5nZUNvbXBvbmVudDxEPj4ge1xuICAgIHByb3RlY3RlZCBwaWNrZXJDbGFzczogVHlwZTxOYkNhbGVuZGFyUmFuZ2VDb21wb25lbnQ8RD4+O1xuICAgIC8qKlxuICAgICAqIFJhbmdlIHdoaWNoIHdpbGwgYmUgcmVuZGVyZWQgYXMgc2VsZWN0ZWQuXG4gICAgICogKi9cbiAgICBzZXQgcmFuZ2UocmFuZ2U6IE5iQ2FsZW5kYXJSYW5nZTxEPik7XG4gICAgLyoqXG4gICAgICogRW1pdHMgcmFuZ2Ugd2hlbiBzdGFydCBzZWxlY3RlZCBhbmQgZW1pdHMgYWdhaW4gd2hlbiBlbmQgc2VsZWN0ZWQuXG4gICAgICogKi9cbiAgICBnZXQgcmFuZ2VDaGFuZ2UoKTogRXZlbnRFbWl0dGVyPE5iQ2FsZW5kYXJSYW5nZTxEPj47XG4gICAgZ2V0IHZhbHVlKCk6IE5iQ2FsZW5kYXJSYW5nZTxEPjtcbiAgICBzZXQgdmFsdWUocmFuZ2U6IE5iQ2FsZW5kYXJSYW5nZTxEPik7XG4gICAgcHJvdGVjdGVkIGdldCBwaWNrZXJWYWx1ZUNoYW5nZSgpOiBPYnNlcnZhYmxlPE5iQ2FsZW5kYXJSYW5nZTxEPj47XG4gICAgc2hvdWxkSGlkZSgpOiBib29sZWFuO1xuICAgIHByb3RlY3RlZCB3cml0ZVF1ZXVlKCk6IHZvaWQ7XG59XG4iXX0=