/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
import { AfterViewInit, ElementRef, OnChanges, OnDestroy, OnInit, EventEmitter } from '@angular/core';
import { NbDynamicOverlay, NbDynamicOverlayController } from '../cdk/overlay/dynamic/dynamic-overlay';
import { NbDynamicOverlayHandler } from '../cdk/overlay/dynamic/dynamic-overlay-handler';
import { NbAdjustment, NbPosition, NbPositionValues } from '../cdk/overlay/overlay-position';
import { NbOverlayContent } from '../cdk/overlay/overlay-service';
import { NbTrigger, NbTriggerValues } from '../cdk/overlay/overlay-trigger';
import { NbPopoverComponent } from './popover.component';
import { Subject } from 'rxjs';
/**
 * Powerful popover directive, which provides the best UX for your users.
 *
 * @stacked-example(Showcase, popover/popover-showcase.component)
 *
 * Popover can accept different content such as:
 * TemplateRef
 *
 * ```html
 * <button [nbPopover]="templateRef"></button>
 * <ng-template #templateRef>
 *   <span>Hello, Popover!</span>
 * </ng-template>
 * ```
 * ### Installation
 *
 * Import `NbPopoverModule` to your feature module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbPopoverModule,
 *   ],
 * })
 * export class PageModule { }
 * ```
 * ### Usage
 *
 * Custom components
 *
 * ```html
 * <button [nbPopover]="MyPopoverComponent"></button>
 * ```
 *
 * Both custom components and templateRef popovers can receive *contentContext* property
 * that will be passed to the content props.
 *
 * Primitive types
 *
 * ```html
 * <button nbPopover="Hello, Popover!"></button>
 * ```
 *
 * Popover has different placements, such as: top, bottom, left, right, start and end
 * which can be used as following:
 *
 * @stacked-example(Placements, popover/popover-placements.component)
 *
 * By default popover will try to adjust itself to maximally fit viewport
 * and provide the best user experience. It will try to change position of the popover container.
 * If you want to disable this behaviour set it `noop`.
 *
 * ```html
 * <button nbPopover="Hello, Popover!" nbPopoverAdjustment="noop"></button>
 * ```
 *
 * Popover has a number of triggers which provides an ability to show and hide the component in different ways:
 *
 * - Click mode shows the component when a user clicks on the host element and hides when the user clicks
 * somewhere on the document outside the component.
 * - Hint provides capability to show the component when the user hovers over the host element
 * and hide when the user hovers out of the host.
 * - Hover works like hint mode with one exception - when the user moves mouse from host element to
 * the container element the component remains open, so that it is possible to interact with it content.
 * - Focus mode is applied when user focuses the element.
 * - Noop mode - the component won't react to the user interaction.
 *
 * @stacked-example(Available Triggers, popover/popover-modes.component.html)
 *
 * Noop mode is especially useful when you need to control Popover programmatically, for example show/hide
 * as a result of some third-party action, like HTTP request or validation check:
 *
 * @stacked-example(Manual Control, popover/popover-noop.component)
 *
 * Below are examples for manual popover settings control, both via template binding and code.
 * @stacked-example(Popover Settings, popover/popover-dynamic.component)
 *
 * Please note, while manipulating Popover setting via code, you need to call `rebuild()` method to apply the settings
 * changed.
 * @stacked-example(Popover Settings Code, popover/popover-dynamic-code.component)
 *
 * @additional-example(Template Ref, popover/popover-template-ref.component)
 * @additional-example(Custom Component, popover/popover-custom-component.component)
 * */
import * as ɵngcc0 from '@angular/core';
export declare class NbPopoverDirective implements NbDynamicOverlayController, OnChanges, AfterViewInit, OnDestroy, OnInit {
    protected hostRef: ElementRef;
    protected dynamicOverlayHandler: NbDynamicOverlayHandler;
    protected popoverComponent: typeof NbPopoverComponent;
    protected dynamicOverlay: NbDynamicOverlay;
    protected destroy$: Subject<void>;
    /**
     * Popover content which will be rendered in NbArrowedOverlayContainerComponent.
     * Available content: template ref, component and any primitive.
     * */
    content: NbOverlayContent;
    /**
     * Container content context. Will be applied to the rendered component.
     * */
    context: Object;
    /**
     * Position will be calculated relatively host element based on the position.
     * Can be top, right, bottom, left, start or end.
     * */
    position: NbPosition;
    static ngAcceptInputType_position: NbPositionValues;
    /**
     * Container position will be changes automatically based on this strategy if container can't fit view port.
     * Set this property to `noop` value if you want to disable automatically adjustment.
     * Available values: `clockwise` (default), `counterclockwise`, `vertical`, `horizontal`, `noop`.
     * */
    get adjustment(): NbAdjustment;
    set adjustment(value: NbAdjustment);
    protected _adjustment: NbAdjustment;
    /**
     * Describes when the container will be shown.
     * Available options: `click`, `hover`, `hint`, `focus` and `noop`
     * */
    trigger: NbTrigger;
    static ngAcceptInputType_trigger: NbTriggerValues;
    /**
     * Sets popover offset
     * */
    offset: number;
    popoverClass: string;
    nbPopoverShowStateChange: EventEmitter<{
        isShown: boolean;
    }>;
    get isShown(): boolean;
    constructor(hostRef: ElementRef, dynamicOverlayHandler: NbDynamicOverlayHandler);
    ngOnInit(): void;
    ngOnChanges(): void;
    ngAfterViewInit(): void;
    rebuild(): void;
    show(): void;
    hide(): void;
    toggle(): void;
    ngOnDestroy(): void;
    protected configureDynamicOverlay(): NbDynamicOverlayHandler;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<NbPopoverDirective, never>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<NbPopoverDirective, "[nbPopover]", ["nbPopover"], { "context": "nbPopoverContext"; "position": "nbPopoverPlacement"; "trigger": "nbPopoverTrigger"; "offset": "nbPopoverOffset"; "popoverClass": "nbPopoverClass"; "adjustment": "nbPopoverAdjustment"; "content": "nbPopover"; }, { "nbPopoverShowStateChange": "nbPopoverShowStateChange"; }, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9wb3Zlci5kaXJlY3RpdmUuZC50cyIsInNvdXJjZXMiOlsicG9wb3Zlci5kaXJlY3RpdmUuZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpR0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBc0RBIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xuaW1wb3J0IHsgQWZ0ZXJWaWV3SW5pdCwgRWxlbWVudFJlZiwgT25DaGFuZ2VzLCBPbkRlc3Ryb3ksIE9uSW5pdCwgRXZlbnRFbWl0dGVyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBOYkR5bmFtaWNPdmVybGF5LCBOYkR5bmFtaWNPdmVybGF5Q29udHJvbGxlciB9IGZyb20gJy4uL2Nkay9vdmVybGF5L2R5bmFtaWMvZHluYW1pYy1vdmVybGF5JztcbmltcG9ydCB7IE5iRHluYW1pY092ZXJsYXlIYW5kbGVyIH0gZnJvbSAnLi4vY2RrL292ZXJsYXkvZHluYW1pYy9keW5hbWljLW92ZXJsYXktaGFuZGxlcic7XG5pbXBvcnQgeyBOYkFkanVzdG1lbnQsIE5iUG9zaXRpb24sIE5iUG9zaXRpb25WYWx1ZXMgfSBmcm9tICcuLi9jZGsvb3ZlcmxheS9vdmVybGF5LXBvc2l0aW9uJztcbmltcG9ydCB7IE5iT3ZlcmxheUNvbnRlbnQgfSBmcm9tICcuLi9jZGsvb3ZlcmxheS9vdmVybGF5LXNlcnZpY2UnO1xuaW1wb3J0IHsgTmJUcmlnZ2VyLCBOYlRyaWdnZXJWYWx1ZXMgfSBmcm9tICcuLi9jZGsvb3ZlcmxheS9vdmVybGF5LXRyaWdnZXInO1xuaW1wb3J0IHsgTmJQb3BvdmVyQ29tcG9uZW50IH0gZnJvbSAnLi9wb3BvdmVyLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG4vKipcbiAqIFBvd2VyZnVsIHBvcG92ZXIgZGlyZWN0aXZlLCB3aGljaCBwcm92aWRlcyB0aGUgYmVzdCBVWCBmb3IgeW91ciB1c2Vycy5cbiAqXG4gKiBAc3RhY2tlZC1leGFtcGxlKFNob3djYXNlLCBwb3BvdmVyL3BvcG92ZXItc2hvd2Nhc2UuY29tcG9uZW50KVxuICpcbiAqIFBvcG92ZXIgY2FuIGFjY2VwdCBkaWZmZXJlbnQgY29udGVudCBzdWNoIGFzOlxuICogVGVtcGxhdGVSZWZcbiAqXG4gKiBgYGBodG1sXG4gKiA8YnV0dG9uIFtuYlBvcG92ZXJdPVwidGVtcGxhdGVSZWZcIj48L2J1dHRvbj5cbiAqIDxuZy10ZW1wbGF0ZSAjdGVtcGxhdGVSZWY+XG4gKiAgIDxzcGFuPkhlbGxvLCBQb3BvdmVyITwvc3Bhbj5cbiAqIDwvbmctdGVtcGxhdGU+XG4gKiBgYGBcbiAqICMjIyBJbnN0YWxsYXRpb25cbiAqXG4gKiBJbXBvcnQgYE5iUG9wb3Zlck1vZHVsZWAgdG8geW91ciBmZWF0dXJlIG1vZHVsZS5cbiAqIGBgYHRzXG4gKiBATmdNb2R1bGUoe1xuICogICBpbXBvcnRzOiBbXG4gKiAgICAgLy8gLi4uXG4gKiAgICAgTmJQb3BvdmVyTW9kdWxlLFxuICogICBdLFxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBQYWdlTW9kdWxlIHsgfVxuICogYGBgXG4gKiAjIyMgVXNhZ2VcbiAqXG4gKiBDdXN0b20gY29tcG9uZW50c1xuICpcbiAqIGBgYGh0bWxcbiAqIDxidXR0b24gW25iUG9wb3Zlcl09XCJNeVBvcG92ZXJDb21wb25lbnRcIj48L2J1dHRvbj5cbiAqIGBgYFxuICpcbiAqIEJvdGggY3VzdG9tIGNvbXBvbmVudHMgYW5kIHRlbXBsYXRlUmVmIHBvcG92ZXJzIGNhbiByZWNlaXZlICpjb250ZW50Q29udGV4dCogcHJvcGVydHlcbiAqIHRoYXQgd2lsbCBiZSBwYXNzZWQgdG8gdGhlIGNvbnRlbnQgcHJvcHMuXG4gKlxuICogUHJpbWl0aXZlIHR5cGVzXG4gKlxuICogYGBgaHRtbFxuICogPGJ1dHRvbiBuYlBvcG92ZXI9XCJIZWxsbywgUG9wb3ZlciFcIj48L2J1dHRvbj5cbiAqIGBgYFxuICpcbiAqIFBvcG92ZXIgaGFzIGRpZmZlcmVudCBwbGFjZW1lbnRzLCBzdWNoIGFzOiB0b3AsIGJvdHRvbSwgbGVmdCwgcmlnaHQsIHN0YXJ0IGFuZCBlbmRcbiAqIHdoaWNoIGNhbiBiZSB1c2VkIGFzIGZvbGxvd2luZzpcbiAqXG4gKiBAc3RhY2tlZC1leGFtcGxlKFBsYWNlbWVudHMsIHBvcG92ZXIvcG9wb3Zlci1wbGFjZW1lbnRzLmNvbXBvbmVudClcbiAqXG4gKiBCeSBkZWZhdWx0IHBvcG92ZXIgd2lsbCB0cnkgdG8gYWRqdXN0IGl0c2VsZiB0byBtYXhpbWFsbHkgZml0IHZpZXdwb3J0XG4gKiBhbmQgcHJvdmlkZSB0aGUgYmVzdCB1c2VyIGV4cGVyaWVuY2UuIEl0IHdpbGwgdHJ5IHRvIGNoYW5nZSBwb3NpdGlvbiBvZiB0aGUgcG9wb3ZlciBjb250YWluZXIuXG4gKiBJZiB5b3Ugd2FudCB0byBkaXNhYmxlIHRoaXMgYmVoYXZpb3VyIHNldCBpdCBgbm9vcGAuXG4gKlxuICogYGBgaHRtbFxuICogPGJ1dHRvbiBuYlBvcG92ZXI9XCJIZWxsbywgUG9wb3ZlciFcIiBuYlBvcG92ZXJBZGp1c3RtZW50PVwibm9vcFwiPjwvYnV0dG9uPlxuICogYGBgXG4gKlxuICogUG9wb3ZlciBoYXMgYSBudW1iZXIgb2YgdHJpZ2dlcnMgd2hpY2ggcHJvdmlkZXMgYW4gYWJpbGl0eSB0byBzaG93IGFuZCBoaWRlIHRoZSBjb21wb25lbnQgaW4gZGlmZmVyZW50IHdheXM6XG4gKlxuICogLSBDbGljayBtb2RlIHNob3dzIHRoZSBjb21wb25lbnQgd2hlbiBhIHVzZXIgY2xpY2tzIG9uIHRoZSBob3N0IGVsZW1lbnQgYW5kIGhpZGVzIHdoZW4gdGhlIHVzZXIgY2xpY2tzXG4gKiBzb21ld2hlcmUgb24gdGhlIGRvY3VtZW50IG91dHNpZGUgdGhlIGNvbXBvbmVudC5cbiAqIC0gSGludCBwcm92aWRlcyBjYXBhYmlsaXR5IHRvIHNob3cgdGhlIGNvbXBvbmVudCB3aGVuIHRoZSB1c2VyIGhvdmVycyBvdmVyIHRoZSBob3N0IGVsZW1lbnRcbiAqIGFuZCBoaWRlIHdoZW4gdGhlIHVzZXIgaG92ZXJzIG91dCBvZiB0aGUgaG9zdC5cbiAqIC0gSG92ZXIgd29ya3MgbGlrZSBoaW50IG1vZGUgd2l0aCBvbmUgZXhjZXB0aW9uIC0gd2hlbiB0aGUgdXNlciBtb3ZlcyBtb3VzZSBmcm9tIGhvc3QgZWxlbWVudCB0b1xuICogdGhlIGNvbnRhaW5lciBlbGVtZW50IHRoZSBjb21wb25lbnQgcmVtYWlucyBvcGVuLCBzbyB0aGF0IGl0IGlzIHBvc3NpYmxlIHRvIGludGVyYWN0IHdpdGggaXQgY29udGVudC5cbiAqIC0gRm9jdXMgbW9kZSBpcyBhcHBsaWVkIHdoZW4gdXNlciBmb2N1c2VzIHRoZSBlbGVtZW50LlxuICogLSBOb29wIG1vZGUgLSB0aGUgY29tcG9uZW50IHdvbid0IHJlYWN0IHRvIHRoZSB1c2VyIGludGVyYWN0aW9uLlxuICpcbiAqIEBzdGFja2VkLWV4YW1wbGUoQXZhaWxhYmxlIFRyaWdnZXJzLCBwb3BvdmVyL3BvcG92ZXItbW9kZXMuY29tcG9uZW50Lmh0bWwpXG4gKlxuICogTm9vcCBtb2RlIGlzIGVzcGVjaWFsbHkgdXNlZnVsIHdoZW4geW91IG5lZWQgdG8gY29udHJvbCBQb3BvdmVyIHByb2dyYW1tYXRpY2FsbHksIGZvciBleGFtcGxlIHNob3cvaGlkZVxuICogYXMgYSByZXN1bHQgb2Ygc29tZSB0aGlyZC1wYXJ0eSBhY3Rpb24sIGxpa2UgSFRUUCByZXF1ZXN0IG9yIHZhbGlkYXRpb24gY2hlY2s6XG4gKlxuICogQHN0YWNrZWQtZXhhbXBsZShNYW51YWwgQ29udHJvbCwgcG9wb3Zlci9wb3BvdmVyLW5vb3AuY29tcG9uZW50KVxuICpcbiAqIEJlbG93IGFyZSBleGFtcGxlcyBmb3IgbWFudWFsIHBvcG92ZXIgc2V0dGluZ3MgY29udHJvbCwgYm90aCB2aWEgdGVtcGxhdGUgYmluZGluZyBhbmQgY29kZS5cbiAqIEBzdGFja2VkLWV4YW1wbGUoUG9wb3ZlciBTZXR0aW5ncywgcG9wb3Zlci9wb3BvdmVyLWR5bmFtaWMuY29tcG9uZW50KVxuICpcbiAqIFBsZWFzZSBub3RlLCB3aGlsZSBtYW5pcHVsYXRpbmcgUG9wb3ZlciBzZXR0aW5nIHZpYSBjb2RlLCB5b3UgbmVlZCB0byBjYWxsIGByZWJ1aWxkKClgIG1ldGhvZCB0byBhcHBseSB0aGUgc2V0dGluZ3NcbiAqIGNoYW5nZWQuXG4gKiBAc3RhY2tlZC1leGFtcGxlKFBvcG92ZXIgU2V0dGluZ3MgQ29kZSwgcG9wb3Zlci9wb3BvdmVyLWR5bmFtaWMtY29kZS5jb21wb25lbnQpXG4gKlxuICogQGFkZGl0aW9uYWwtZXhhbXBsZShUZW1wbGF0ZSBSZWYsIHBvcG92ZXIvcG9wb3Zlci10ZW1wbGF0ZS1yZWYuY29tcG9uZW50KVxuICogQGFkZGl0aW9uYWwtZXhhbXBsZShDdXN0b20gQ29tcG9uZW50LCBwb3BvdmVyL3BvcG92ZXItY3VzdG9tLWNvbXBvbmVudC5jb21wb25lbnQpXG4gKiAqL1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgTmJQb3BvdmVyRGlyZWN0aXZlIGltcGxlbWVudHMgTmJEeW5hbWljT3ZlcmxheUNvbnRyb2xsZXIsIE9uQ2hhbmdlcywgQWZ0ZXJWaWV3SW5pdCwgT25EZXN0cm95LCBPbkluaXQge1xuICAgIHByb3RlY3RlZCBob3N0UmVmOiBFbGVtZW50UmVmO1xuICAgIHByb3RlY3RlZCBkeW5hbWljT3ZlcmxheUhhbmRsZXI6IE5iRHluYW1pY092ZXJsYXlIYW5kbGVyO1xuICAgIHByb3RlY3RlZCBwb3BvdmVyQ29tcG9uZW50OiB0eXBlb2YgTmJQb3BvdmVyQ29tcG9uZW50O1xuICAgIHByb3RlY3RlZCBkeW5hbWljT3ZlcmxheTogTmJEeW5hbWljT3ZlcmxheTtcbiAgICBwcm90ZWN0ZWQgZGVzdHJveSQ6IFN1YmplY3Q8dm9pZD47XG4gICAgLyoqXG4gICAgICogUG9wb3ZlciBjb250ZW50IHdoaWNoIHdpbGwgYmUgcmVuZGVyZWQgaW4gTmJBcnJvd2VkT3ZlcmxheUNvbnRhaW5lckNvbXBvbmVudC5cbiAgICAgKiBBdmFpbGFibGUgY29udGVudDogdGVtcGxhdGUgcmVmLCBjb21wb25lbnQgYW5kIGFueSBwcmltaXRpdmUuXG4gICAgICogKi9cbiAgICBjb250ZW50OiBOYk92ZXJsYXlDb250ZW50O1xuICAgIC8qKlxuICAgICAqIENvbnRhaW5lciBjb250ZW50IGNvbnRleHQuIFdpbGwgYmUgYXBwbGllZCB0byB0aGUgcmVuZGVyZWQgY29tcG9uZW50LlxuICAgICAqICovXG4gICAgY29udGV4dDogT2JqZWN0O1xuICAgIC8qKlxuICAgICAqIFBvc2l0aW9uIHdpbGwgYmUgY2FsY3VsYXRlZCByZWxhdGl2ZWx5IGhvc3QgZWxlbWVudCBiYXNlZCBvbiB0aGUgcG9zaXRpb24uXG4gICAgICogQ2FuIGJlIHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdCwgc3RhcnQgb3IgZW5kLlxuICAgICAqICovXG4gICAgcG9zaXRpb246IE5iUG9zaXRpb247XG4gICAgc3RhdGljIG5nQWNjZXB0SW5wdXRUeXBlX3Bvc2l0aW9uOiBOYlBvc2l0aW9uVmFsdWVzO1xuICAgIC8qKlxuICAgICAqIENvbnRhaW5lciBwb3NpdGlvbiB3aWxsIGJlIGNoYW5nZXMgYXV0b21hdGljYWxseSBiYXNlZCBvbiB0aGlzIHN0cmF0ZWd5IGlmIGNvbnRhaW5lciBjYW4ndCBmaXQgdmlldyBwb3J0LlxuICAgICAqIFNldCB0aGlzIHByb3BlcnR5IHRvIGBub29wYCB2YWx1ZSBpZiB5b3Ugd2FudCB0byBkaXNhYmxlIGF1dG9tYXRpY2FsbHkgYWRqdXN0bWVudC5cbiAgICAgKiBBdmFpbGFibGUgdmFsdWVzOiBgY2xvY2t3aXNlYCAoZGVmYXVsdCksIGBjb3VudGVyY2xvY2t3aXNlYCwgYHZlcnRpY2FsYCwgYGhvcml6b250YWxgLCBgbm9vcGAuXG4gICAgICogKi9cbiAgICBnZXQgYWRqdXN0bWVudCgpOiBOYkFkanVzdG1lbnQ7XG4gICAgc2V0IGFkanVzdG1lbnQodmFsdWU6IE5iQWRqdXN0bWVudCk7XG4gICAgcHJvdGVjdGVkIF9hZGp1c3RtZW50OiBOYkFkanVzdG1lbnQ7XG4gICAgLyoqXG4gICAgICogRGVzY3JpYmVzIHdoZW4gdGhlIGNvbnRhaW5lciB3aWxsIGJlIHNob3duLlxuICAgICAqIEF2YWlsYWJsZSBvcHRpb25zOiBgY2xpY2tgLCBgaG92ZXJgLCBgaGludGAsIGBmb2N1c2AgYW5kIGBub29wYFxuICAgICAqICovXG4gICAgdHJpZ2dlcjogTmJUcmlnZ2VyO1xuICAgIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV90cmlnZ2VyOiBOYlRyaWdnZXJWYWx1ZXM7XG4gICAgLyoqXG4gICAgICogU2V0cyBwb3BvdmVyIG9mZnNldFxuICAgICAqICovXG4gICAgb2Zmc2V0OiBudW1iZXI7XG4gICAgcG9wb3ZlckNsYXNzOiBzdHJpbmc7XG4gICAgbmJQb3BvdmVyU2hvd1N0YXRlQ2hhbmdlOiBFdmVudEVtaXR0ZXI8e1xuICAgICAgICBpc1Nob3duOiBib29sZWFuO1xuICAgIH0+O1xuICAgIGdldCBpc1Nob3duKCk6IGJvb2xlYW47XG4gICAgY29uc3RydWN0b3IoaG9zdFJlZjogRWxlbWVudFJlZiwgZHluYW1pY092ZXJsYXlIYW5kbGVyOiBOYkR5bmFtaWNPdmVybGF5SGFuZGxlcik7XG4gICAgbmdPbkluaXQoKTogdm9pZDtcbiAgICBuZ09uQ2hhbmdlcygpOiB2b2lkO1xuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkO1xuICAgIHJlYnVpbGQoKTogdm9pZDtcbiAgICBzaG93KCk6IHZvaWQ7XG4gICAgaGlkZSgpOiB2b2lkO1xuICAgIHRvZ2dsZSgpOiB2b2lkO1xuICAgIG5nT25EZXN0cm95KCk6IHZvaWQ7XG4gICAgcHJvdGVjdGVkIGNvbmZpZ3VyZUR5bmFtaWNPdmVybGF5KCk6IE5iRHluYW1pY092ZXJsYXlIYW5kbGVyO1xufVxuIl19